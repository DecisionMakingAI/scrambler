{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Scrambler Donkey Car by Dale Jordan February 14, 2020 The Donkeycar has a well established set of software tools and hardware platform for developing machine learning algorithms in a self driving car environment. The basic donkeycar using the Jetson Nano processor was used as the starting point for the Scrambler project. Reference documentation for the basic donkeycar can be found at: https://docs.donkeycar.com/ . The Scrambler Donkeycar was setup using this procedure as a guide. Several enhancements were made to the basic hardware design. The Jetson Nano can consume batteries rather quickly, especially if trying to run in its high power mode. A more powerful processor battery was installed along with a power regulator and display for monitoring battery state. A display was also added to monitor the car's drive battery state. These additions necessitated a redesign of the 3D printed hardware for the car. The software installation procedure of the basic car was used largely as. There were a few caveats in the installation. These were most likey due to changes in the updated linux kernel that produced some incompatabilities. The steps used are listed in the Software Installation section. The reference document was cut and pasted here, then annotated as necessary. Also, when moving to a new location, the network parameters will have to be adjusted. Tools and a procedure are outlined for doing this as a headless system. Getting Started Getting started involves a few key steps: Unpack and finish assembling the car Modify the software to operate in the local environment Run the Donkeycar software to verify and or finish adjusting the car","title":"Introduction"},{"location":"index.html#scrambler-donkey-car","text":"by Dale Jordan February 14, 2020 The Donkeycar has a well established set of software tools and hardware platform for developing machine learning algorithms in a self driving car environment. The basic donkeycar using the Jetson Nano processor was used as the starting point for the Scrambler project. Reference documentation for the basic donkeycar can be found at: https://docs.donkeycar.com/ . The Scrambler Donkeycar was setup using this procedure as a guide. Several enhancements were made to the basic hardware design. The Jetson Nano can consume batteries rather quickly, especially if trying to run in its high power mode. A more powerful processor battery was installed along with a power regulator and display for monitoring battery state. A display was also added to monitor the car's drive battery state. These additions necessitated a redesign of the 3D printed hardware for the car. The software installation procedure of the basic car was used largely as. There were a few caveats in the installation. These were most likey due to changes in the updated linux kernel that produced some incompatabilities. The steps used are listed in the Software Installation section. The reference document was cut and pasted here, then annotated as necessary. Also, when moving to a new location, the network parameters will have to be adjusted. Tools and a procedure are outlined for doing this as a headless system.","title":"Scrambler Donkey Car"},{"location":"index.html#getting-started","text":"Getting started involves a few key steps: Unpack and finish assembling the car Modify the software to operate in the local environment Run the Donkeycar software to verify and or finish adjusting the car","title":"Getting Started"},{"location":"chargingbatteries.html","text":"The charger is capable of charging both the 2S and 3S batteries. There is a balancing port for each type. Only one battery may be charged at a time. The charging leads on the batteries are rather short, so JST-XH extension cables are used to solve this problem. They provide one additional benefit, in that wear and tear happens on the extension cable and not the charger connector. To charge a battery, just lift the charging cable from the housing on the car and plug it into the appropriate extensin cable on the charger. The cable housing on the car is there to hold the cable in place so it can't fall down and get caught in the wheel. Charging Processor Battery: Charging Drive System Battery:","title":"Charging Batteries"},{"location":"generalnotes.html","text":"This section lists some general things that may be observed through operation. Processor Power Current Limiting If the orange light comes on on the processor panel, the regulator has gone into current limit mode. This light can be seen through the rectangular hole on the processor panel near the V adjustment area. This should not happen under normal operation. Causes of this are a short in the output, processor is drawing more power than regulator can output or the I-adjust control is set too low. If the regulator current limits excessively, it can cause a brown-out on the processor and force it to reset. To increase the current level output, turn the I-adjust control clockwise. If adding electrical components to the car, it is important to note that the regulator has a current sense resistor on the ground side of the system. Thus, the negative side of the battery is not at the same level as the 5V ground to the processor. The drive system battery and the 5V ground end up at the same level through the wiring of the PWM module. Should the processor battery negative lead be brought to the same level as the 5V ground, this will effectively short out the sensing resistor and damage to the regulator will result. Output Voltage Increases with Processor Load If you observing the ouput voltage on the display, you may notice that it may increase as much as 0.2V as the processor pulls a heavy load. This is normal because of the sense resistor in the ground path on the regulator. The actual input voltage remains at the unloaded reading value. Car Suspension Adding the processor battery, 3D printed parts and other electronics increases the weight of the car by about 650g (23 oz). If the suspension appears to be sagging too much, go to the Exceed RC web-site for instructional videos on changing shock oil and adjusting spring tension. Using Jetson Nano Serial Ports There may be times that it is useful to connect to a serial console port to gain control of the system. There are two serial UART ports on the Jetson Nano. The port on J44 is the system serial console port. The other serial port is on J41. This port is mixed in with other I/O pins. Many users report having difficulty in connecting to the serial port on J41. There seems to be little information on the web to help resolve this issue. The version of firmware downloaded for this car also exhibits this problem. For purposes of getting things up and running, only J44 will be used. A nice tutorial by JetsonHacks covers many elements of getting connected to the serial console. USB to TTL Cables are available from several sources. This one is readily available. The cable is not all that long, so to make connections easier, it may be necessary to attach this cable to the host through a USB extension cable. The serial device is connected to the J44 on the Jetson Nano as follows: J44 Pin Cable Wire 2 (TXD) White (RXD) 3 (RXD) Green (TXD) 6 (GND) Black (GND) NC Red (5V) The J44 port runs at logic levels of 3.3V and is not 5V compatible. The red lead on the USB to TTL device is a 5V source and is not needed and must not be connected to pins on J44. Note: RXD on the cable is connected to TXD on the Nano and vice versa. This has to do with labeling conventions. The following picture shows the connection of this device. Also note that the 5V lead is taped up out of the way so that it cannot inadvertantly short to anything on the board. There are many serial terminal emulators available. The example here will use screen . If not already installed on the host, it can be simply done via: sudo apt-get update sudo apt-get install screen To discover which port the USB to TTL convertor is plugged into, open a terminal window and type the following command: dmesg --follow Then plug the USB device in and observe the output of dmesg. It will typically show that the device is connected to a port such as ttyUSB0 . Exit out of the dmesg command. Start up the terminal emulator with the command: screen /dev/*<device>* 115200 You should now be able to login to the machine.","title":"General Operating Notes"},{"location":"generalnotes.html#processor-power-current-limiting","text":"If the orange light comes on on the processor panel, the regulator has gone into current limit mode. This light can be seen through the rectangular hole on the processor panel near the V adjustment area. This should not happen under normal operation. Causes of this are a short in the output, processor is drawing more power than regulator can output or the I-adjust control is set too low. If the regulator current limits excessively, it can cause a brown-out on the processor and force it to reset. To increase the current level output, turn the I-adjust control clockwise. If adding electrical components to the car, it is important to note that the regulator has a current sense resistor on the ground side of the system. Thus, the negative side of the battery is not at the same level as the 5V ground to the processor. The drive system battery and the 5V ground end up at the same level through the wiring of the PWM module. Should the processor battery negative lead be brought to the same level as the 5V ground, this will effectively short out the sensing resistor and damage to the regulator will result.","title":"Processor Power Current Limiting"},{"location":"generalnotes.html#output-voltage-increases-with-processor-load","text":"If you observing the ouput voltage on the display, you may notice that it may increase as much as 0.2V as the processor pulls a heavy load. This is normal because of the sense resistor in the ground path on the regulator. The actual input voltage remains at the unloaded reading value.","title":"Output Voltage Increases with Processor Load"},{"location":"generalnotes.html#car-suspension","text":"Adding the processor battery, 3D printed parts and other electronics increases the weight of the car by about 650g (23 oz). If the suspension appears to be sagging too much, go to the Exceed RC web-site for instructional videos on changing shock oil and adjusting spring tension.","title":"Car Suspension"},{"location":"generalnotes.html#using-jetson-nano-serial-ports","text":"There may be times that it is useful to connect to a serial console port to gain control of the system. There are two serial UART ports on the Jetson Nano. The port on J44 is the system serial console port. The other serial port is on J41. This port is mixed in with other I/O pins. Many users report having difficulty in connecting to the serial port on J41. There seems to be little information on the web to help resolve this issue. The version of firmware downloaded for this car also exhibits this problem. For purposes of getting things up and running, only J44 will be used. A nice tutorial by JetsonHacks covers many elements of getting connected to the serial console. USB to TTL Cables are available from several sources. This one is readily available. The cable is not all that long, so to make connections easier, it may be necessary to attach this cable to the host through a USB extension cable. The serial device is connected to the J44 on the Jetson Nano as follows: J44 Pin Cable Wire 2 (TXD) White (RXD) 3 (RXD) Green (TXD) 6 (GND) Black (GND) NC Red (5V) The J44 port runs at logic levels of 3.3V and is not 5V compatible. The red lead on the USB to TTL device is a 5V source and is not needed and must not be connected to pins on J44. Note: RXD on the cable is connected to TXD on the Nano and vice versa. This has to do with labeling conventions. The following picture shows the connection of this device. Also note that the 5V lead is taped up out of the way so that it cannot inadvertantly short to anything on the board. There are many serial terminal emulators available. The example here will use screen . If not already installed on the host, it can be simply done via: sudo apt-get update sudo apt-get install screen To discover which port the USB to TTL convertor is plugged into, open a terminal window and type the following command: dmesg --follow Then plug the USB device in and observe the output of dmesg. It will typically show that the device is connected to a port such as ttyUSB0 . Exit out of the dmesg command. Start up the terminal emulator with the command: screen /dev/*<device>* 115200 You should now be able to login to the machine.","title":"Using Jetson Nano Serial Ports"},{"location":"headless_setup.html","text":"If an extra display, keyboard and mouse are available, you can go through the no rmal gui interface to establish the necessary WiFi connections to get the car up and running. For situations where this is not available, a headless setup procedure can be used. It requires a terminal emulator on the host and a USB cable connected between the host and the micro USB port on the Jetson Nano. Host Setup There are many serial terminals available and almost any will do. The example here will use screen on a linux machine. If you are on a windows machine, puTTY is a good emulator to use. If not already installed on the host, it can be simply done via: sudo apt-get update sudo apt-get install screen To discover which port the USB cable is plugged into, open a terminal window and type the following command: dmesg --follow Connect the USB cable between the Jetson Nano and the host, and observe the output of dmesg. Somewhere in the spew of information, some TTY port information will show up. Typically, the port will show up as ttyACM0 . Exit out of the dmesg command. Start up the terminal emulator with the command: sudo screen /dev/ttyACM0 115200 You are now ready to log into the port. Configuring WiFi Parameters In configuring a WiFi setting, there are three types of variables of interest: Variable Values <SavedWiFiConnections> list of saved connections <WiFiSSID> available networks <WiFiInterface> device interfaces This information can all be queried through the following commands # Get a list of saved connections (<SavedWiFiConnections>) nmcli c # Get a list of available networks (<WiFiSSID>) nmcli d wifi list # optionally to get a fresh list nmcli d wifi list rescan # To get the list of interfaces (<WiFiInterface>): # Typically the value of interest is: wlan0 ifconfig -a In the commands below, substitute the environment values for <SavedWiFiConnections>, <WiFiSSID>, and <WiFiInterface>. Note that the shorthand arguments 'c' and 'd' stand for 'connection' and 'device' respectively. # disconnect from a network sudo nmcli c down <SavedWiFiConnection> # connect to a saved network sudo nmcli c up <SavedWiFiConnection> # If password is not automatically recognized issue this command sudo nmcli -a c up <SavedWiFiConnection> To connect to a new network, issue the following command. The -a stands for 'ask' for the password. The connection should be saved and will reconnect automatically the next time the processor is booted. sudo nmcli -a d wifi connect <WiFiSSID> To forget a connection: sudo nmcli c delete <SavedWiFiConnection> Changing Current Time Zone if Necessary sudo dpkg-reconfigure tzdata When the menu comes up select the appropriate country, e.g., America. Then select from a list of cities in your time zone.","title":"Headless Setup"},{"location":"headless_setup.html#host-setup","text":"There are many serial terminals available and almost any will do. The example here will use screen on a linux machine. If you are on a windows machine, puTTY is a good emulator to use. If not already installed on the host, it can be simply done via: sudo apt-get update sudo apt-get install screen To discover which port the USB cable is plugged into, open a terminal window and type the following command: dmesg --follow Connect the USB cable between the Jetson Nano and the host, and observe the output of dmesg. Somewhere in the spew of information, some TTY port information will show up. Typically, the port will show up as ttyACM0 . Exit out of the dmesg command. Start up the terminal emulator with the command: sudo screen /dev/ttyACM0 115200 You are now ready to log into the port.","title":"Host Setup"},{"location":"headless_setup.html#configuring-wifi-parameters","text":"In configuring a WiFi setting, there are three types of variables of interest: Variable Values <SavedWiFiConnections> list of saved connections <WiFiSSID> available networks <WiFiInterface> device interfaces This information can all be queried through the following commands # Get a list of saved connections (<SavedWiFiConnections>) nmcli c # Get a list of available networks (<WiFiSSID>) nmcli d wifi list # optionally to get a fresh list nmcli d wifi list rescan # To get the list of interfaces (<WiFiInterface>): # Typically the value of interest is: wlan0 ifconfig -a In the commands below, substitute the environment values for <SavedWiFiConnections>, <WiFiSSID>, and <WiFiInterface>. Note that the shorthand arguments 'c' and 'd' stand for 'connection' and 'device' respectively. # disconnect from a network sudo nmcli c down <SavedWiFiConnection> # connect to a saved network sudo nmcli c up <SavedWiFiConnection> # If password is not automatically recognized issue this command sudo nmcli -a c up <SavedWiFiConnection> To connect to a new network, issue the following command. The -a stands for 'ask' for the password. The connection should be saved and will reconnect automatically the next time the processor is booted. sudo nmcli -a d wifi connect <WiFiSSID> To forget a connection: sudo nmcli c delete <SavedWiFiConnection>","title":"Configuring WiFi Parameters"},{"location":"headless_setup.html#changing-current-time-zone-if-necessary","text":"sudo dpkg-reconfigure tzdata When the menu comes up select the appropriate country, e.g., America. Then select from a list of cities in your time zone.","title":"Changing Current Time Zone if Necessary"},{"location":"initialsetup.html","text":"Package Contents The package contains everything necessary to get the car up and running, except a host computer. Items in the package are: Partially assembled Donkeycar LiPo Battery charger (for charging both the 2S motor and 3S processor batteries) JST-XH 2S 6\" Balance Charging Extension Cable JST-XH 3S 6\" Balance Charging Extension Cable External 5V 5A power supply for operating the Jetson Nano in a stationary position USB Card Reader/Writer/OTG Adapter to handle reading and writing the micro SD card USB to serial port adapter for configuring the Jetson Nano host port and other RS-232 ports USB A to micro B cable USB extension cable, 6.5' for extending USB cables F710 wireless joystick for car remote control Second camera with camera mount (camera with normal lense) Assorted spare parts including clip and jumper pins Block to raise car off ground for testing Assorted shock spacers to adjust the car to sit level Small tools, for mounting and unmounting parts on the car Inspect Car Look car over for damage during shipment. Insure power switch on top of the ESC (Electronic Speed Control) of the car chassis is on. It is left on and the side panel switch will be used to enable power to the drive system. Insure jumper on top of ESC is set to the LiPo position. Car Assembly The car was partially disassembled for compact packing and part protection so it could be shipped in the original container for the Exceed RC car. Go to Final Car Assembly to finish the assembly. Charge batteries The Charging Batteries section illustrates connecting the charger to each of the batteries. Even though the charger has two ports, it can only charge one battery at a time. For shipping, the batteries are set to about a 50% charge or less for safety. Prepare F710 Joystick All that needs to be done to ready the joystick is to insert the two AA batteries. The USB receiver is already plugged in to the processor. The joystick battery compartment has location to store the USB receiver, should it no longer be needed on the car. Login Information A default user is set up on the Jetson Nano with a user name: donkey and password: donkey Headless Setup of WiFi Connections When run at a new location, networking parameters will have to be configured. See the Headless Setup section to perform this setup. If an extra display, keyboard and mouse are available, you can go through the normal gui interface to establish WiFi connections instead. Set and Query Processor Power Mode The Jetson Nano has two basic operating power modes. A 5W mode so that it can run off power from the mini USB connector. And a 10W mode that enables usage of the full processor performance. 10W mode can be used when power is supplied to the barrel jack on development board. To enable power from this source, a jumper must be placed on J48. The processor power levels can then be set and queried with the following commands: # Set to 10W mode sudo nvpmodel -m 0 # Set to 5W mode sudo nvpmodel -m 1 # Query the power setting sudo nvpmodel -q Setup Donkey Software The Install the software section of the reference guide covers the necessary topics. Follow the section on \"Install Software on Host PC\". The Donkey software has already been installed on the donkey car. It takes several hours, so you probably don't want to repeat it unless necessary. There were caveats in the basic install. The Software Installation of this document covers this in detail. TensorRT can be setup on the Jetson Nano as described in the reference document, but has not been done. Following the Donkeycar setup is a \"create your car application\" and \"calibrate your car\". These operations have been done. You should follow through these sections to familiarize yourself with the car software. After all this, you are ready to go out on your own. Shock Spacers The weight of this car is somewhat heavier than the standard car as shipped. Some spacers for the shocks were 3D printed. Four 5mm spacers (one to each shock) were added to the rear shocks to get it to sit level.","title":"Initial Setup"},{"location":"initialsetup.html#package-contents","text":"The package contains everything necessary to get the car up and running, except a host computer. Items in the package are: Partially assembled Donkeycar LiPo Battery charger (for charging both the 2S motor and 3S processor batteries) JST-XH 2S 6\" Balance Charging Extension Cable JST-XH 3S 6\" Balance Charging Extension Cable External 5V 5A power supply for operating the Jetson Nano in a stationary position USB Card Reader/Writer/OTG Adapter to handle reading and writing the micro SD card USB to serial port adapter for configuring the Jetson Nano host port and other RS-232 ports USB A to micro B cable USB extension cable, 6.5' for extending USB cables F710 wireless joystick for car remote control Second camera with camera mount (camera with normal lense) Assorted spare parts including clip and jumper pins Block to raise car off ground for testing Assorted shock spacers to adjust the car to sit level Small tools, for mounting and unmounting parts on the car","title":"Package Contents"},{"location":"initialsetup.html#inspect-car","text":"Look car over for damage during shipment. Insure power switch on top of the ESC (Electronic Speed Control) of the car chassis is on. It is left on and the side panel switch will be used to enable power to the drive system. Insure jumper on top of ESC is set to the LiPo position.","title":"Inspect Car"},{"location":"initialsetup.html#car-assembly","text":"The car was partially disassembled for compact packing and part protection so it could be shipped in the original container for the Exceed RC car. Go to Final Car Assembly to finish the assembly.","title":"Car Assembly"},{"location":"initialsetup.html#charge-batteries","text":"The Charging Batteries section illustrates connecting the charger to each of the batteries. Even though the charger has two ports, it can only charge one battery at a time. For shipping, the batteries are set to about a 50% charge or less for safety.","title":"Charge batteries"},{"location":"initialsetup.html#prepare-f710-joystick","text":"All that needs to be done to ready the joystick is to insert the two AA batteries. The USB receiver is already plugged in to the processor. The joystick battery compartment has location to store the USB receiver, should it no longer be needed on the car.","title":"Prepare F710 Joystick"},{"location":"initialsetup.html#login-information","text":"A default user is set up on the Jetson Nano with a user name: donkey and password: donkey","title":"Login Information"},{"location":"initialsetup.html#headless-setup-of-wifi-connections","text":"When run at a new location, networking parameters will have to be configured. See the Headless Setup section to perform this setup. If an extra display, keyboard and mouse are available, you can go through the normal gui interface to establish WiFi connections instead.","title":"Headless Setup of WiFi Connections"},{"location":"initialsetup.html#set-and-query-processor-power-mode","text":"The Jetson Nano has two basic operating power modes. A 5W mode so that it can run off power from the mini USB connector. And a 10W mode that enables usage of the full processor performance. 10W mode can be used when power is supplied to the barrel jack on development board. To enable power from this source, a jumper must be placed on J48. The processor power levels can then be set and queried with the following commands: # Set to 10W mode sudo nvpmodel -m 0 # Set to 5W mode sudo nvpmodel -m 1 # Query the power setting sudo nvpmodel -q","title":"Set and Query Processor Power Mode"},{"location":"initialsetup.html#setup-donkey-software","text":"The Install the software section of the reference guide covers the necessary topics. Follow the section on \"Install Software on Host PC\". The Donkey software has already been installed on the donkey car. It takes several hours, so you probably don't want to repeat it unless necessary. There were caveats in the basic install. The Software Installation of this document covers this in detail. TensorRT can be setup on the Jetson Nano as described in the reference document, but has not been done. Following the Donkeycar setup is a \"create your car application\" and \"calibrate your car\". These operations have been done. You should follow through these sections to familiarize yourself with the car software. After all this, you are ready to go out on your own.","title":"Setup Donkey Software"},{"location":"initialsetup.html#shock-spacers","text":"The weight of this car is somewhat heavier than the standard car as shipped. Some spacers for the shocks were 3D printed. Four 5mm spacers (one to each shock) were added to the rear shocks to get it to sit level.","title":"Shock Spacers"},{"location":"powermonitor.html","text":"Drive Motor Power Monitoring The drive train is powered by a 2 cell 1.8Ah battery. This battery voltage as read on the panel meter should not be allowed to drop below 6V (3V per cell). This will avoid causing damage to the battery. The Electronic Speed Control (ESC) has built-in cut-off circuitry, but that should be considered a last ditch fail-safe method. Also, make sure that the jumper on top of the ESC is in the LiPo position. The LiPo battery has a separate 3-wire balanced charging cable, so it is not necessary to unplug the battery for charging. Computer Power Monitoring The processor is powered by a 3 cell 3.0Ah battery. The loaded battery level should not be allowed to go below 9V to avoid causing damage to the battery. To be able to read this, the regulator display should be set to display the input voltage. If the display is not showing the inut voltage, press the 'set' button until it does, then press the 'ent' button. The display also continuously displays the output current, so you can watch how hard the processor is working. The following graph shows the discharge time under a constant heavy load (3A). This 3A draw covers the case of a heavily loaded cpu and gpu along with power to other hardware devices connected to the processor. The processor draws slightly less than 0.5A when idling. Moderate cpu activity typically draws less than 1A. With a very heavily loaded cpu and gpu (approximately 3A draw), it should run for one hour and 45 minutes. With a lightly load cpu, then an excess of a 5 hour running time is possible. This LiPo battery has a separate 4-wire balanced charging cable, so it is not necessary to unplug the battery for charging. LiPo Battery Care and Usage LiPo batteries provide a lot of power for their small size and weight, and as such see widespread use in many RC applications. They also require appropriate care to get the best performance and long life. This article on RC Helicopter Fun provides many insights and tips for LiPo battery usage. Some facts about LiPo Batteries: Nominal voltage is 3.7V per cell Fully charged as high as 4.2V per cell 50% discharge is 3.85V per cell 80% discharge is 3.75V per cell Do not discharge below 3V per cell under load or damage will occur Store batteries charged but not fully charged (40-60% or 3.85V per cell open circuit resting voltage)","title":"Power Monitoring"},{"location":"powermonitor.html#drive-motor-power-monitoring","text":"The drive train is powered by a 2 cell 1.8Ah battery. This battery voltage as read on the panel meter should not be allowed to drop below 6V (3V per cell). This will avoid causing damage to the battery. The Electronic Speed Control (ESC) has built-in cut-off circuitry, but that should be considered a last ditch fail-safe method. Also, make sure that the jumper on top of the ESC is in the LiPo position. The LiPo battery has a separate 3-wire balanced charging cable, so it is not necessary to unplug the battery for charging.","title":"Drive Motor Power Monitoring"},{"location":"powermonitor.html#computer-power-monitoring","text":"The processor is powered by a 3 cell 3.0Ah battery. The loaded battery level should not be allowed to go below 9V to avoid causing damage to the battery. To be able to read this, the regulator display should be set to display the input voltage. If the display is not showing the inut voltage, press the 'set' button until it does, then press the 'ent' button. The display also continuously displays the output current, so you can watch how hard the processor is working. The following graph shows the discharge time under a constant heavy load (3A). This 3A draw covers the case of a heavily loaded cpu and gpu along with power to other hardware devices connected to the processor. The processor draws slightly less than 0.5A when idling. Moderate cpu activity typically draws less than 1A. With a very heavily loaded cpu and gpu (approximately 3A draw), it should run for one hour and 45 minutes. With a lightly load cpu, then an excess of a 5 hour running time is possible. This LiPo battery has a separate 4-wire balanced charging cable, so it is not necessary to unplug the battery for charging.","title":"Computer Power Monitoring"},{"location":"powermonitor.html#lipo-battery-care-and-usage","text":"LiPo batteries provide a lot of power for their small size and weight, and as such see widespread use in many RC applications. They also require appropriate care to get the best performance and long life. This article on RC Helicopter Fun provides many insights and tips for LiPo battery usage. Some facts about LiPo Batteries: Nominal voltage is 3.7V per cell Fully charged as high as 4.2V per cell 50% discharge is 3.85V per cell 80% discharge is 3.75V per cell Do not discharge below 3V per cell under load or damage will occur Store batteries charged but not fully charged (40-60% or 3.85V per cell open circuit resting voltage)","title":"LiPo Battery Care and Usage"},{"location":"sd_card_backup.html","text":"Backup the SD Card Rebuilding the Jetson Nano image is a lengthy process should the SD card get corrupted. Doing periodic snapshots of the SD card, can give suitable restore points should the inevitable happen. On the host machine, issue the following command and note the output. df -h Insert the SD card and reissue the command: df -h Look for what is added to the list and this is location of the SD card. The SD card may contain multiple partitions, so use the base part of the name, i.e., /dev/sdc1, use /dev/sdc. Go to the directory you wish to save the image into and issue the following command: sudo dd bs=4M if=/dev/sdc status=progress | gzip >filename.gz Since the SD card is large and the transfer time long, including the status=progress is useful to insure that the operation is working. Restore To restore the SD card image, follow the initial image flashing instructions using etcher. Note: these operations take hours to complete given the 128GB size of the SD card. Further study needs to be done to see how this can be speeded up.","title":"Software Backup"},{"location":"sd_card_backup.html#backup-the-sd-card","text":"Rebuilding the Jetson Nano image is a lengthy process should the SD card get corrupted. Doing periodic snapshots of the SD card, can give suitable restore points should the inevitable happen. On the host machine, issue the following command and note the output. df -h Insert the SD card and reissue the command: df -h Look for what is added to the list and this is location of the SD card. The SD card may contain multiple partitions, so use the base part of the name, i.e., /dev/sdc1, use /dev/sdc. Go to the directory you wish to save the image into and issue the following command: sudo dd bs=4M if=/dev/sdc status=progress | gzip >filename.gz Since the SD card is large and the transfer time long, including the status=progress is useful to insure that the operation is working.","title":"Backup the SD Card"},{"location":"sd_card_backup.html#restore","text":"To restore the SD card image, follow the initial image flashing instructions using etcher. Note: these operations take hours to complete given the 128GB size of the SD card. Further study needs to be done to see how this can be speeded up.","title":"Restore"},{"location":"setup_jetson_nano.html","text":"Get Your Jetson Nano Working This block was lifted from the main donkeycar manual and annotated with the necessary changes to get the software to install. Step 1: Flash Operating System Step 2: Install Dependencies Step 3: Setup Virtual Env Step 4: Install OpenCV Step 5: Install Donkeycar Python Code Step 1: Flash Operating System Visit the official Nvidia Jetson Nano Getting Started Guide . Work through the Prepare for Setup , Writing Image to the microSD Card , and Setup and First Boot instructions, then return here. The operating system flashed was r32.3.1. Setup the following: machine name: scrambler user name/password: donkey/donkey To check the software installed, ran the following command with the subsequent output: donkey@scrambler:~$ hostnamectl Static hostname: scrambler Icon name: computer Machine ID: ca67ded01f62474199a2c58cfd607d5f Boot ID: 81993f68dfcb47189da8918825844916 Operating System: Ubuntu 18.04.4 LTS Kernel: Linux 4.9.140-tegra Architecture: arm64 Step 2: Install Dependencies ssh into your vehicle. Use the the terminal for Ubuntu or Mac. Putty for windows. sudo apt-get update sudo apt-get upgrade sudo apt-get install build-essential python3 python3-dev python3-pip libhdf5-serial-dev hdf5-tools nano ntp Optionally, you can install RPi.GPIO clone for Jetson Nano from here . This is not required for default setup, but can be useful if using LED or other GPIO driven devices. This didn't, so we'll find a better procedure when this is needed. Step 3: Setup Virtual Env The following code was changed, since it exposed a bug when installing the donkeycar code. pip3 install virtualenv python3 -m virtualenv -p python3 env --system-site-packages echo \"source env/bin/activate\" >> ~/.bashrc source ~/.bashrc The two important differences were made to the installation. Install virtualenv in system space as opposed to user space. Having this is user space was one precondition for the legacy error when installing the donkeycar system. Added virtualenvwrapper, as it provides a nicer interface. Here is a reference to using this environment. This is the code executed. # This command actually upgraded pip from what was there python3 -m pip install -U pip # sudo gives it permission to write into system space sudo -H python3 -m pip install virtualenv echo \"export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3\" >>~/.bashrc source ~/.bashrc sudo -H python3 -m pip install virtualenvwrapper mkdir $HOME/.virtualenvs echo \"export WORKON_HOME=$HOME/.virtualenvs\" >>~/.bashrc echo \"source \"`which virtualenvwrapper.sh` >>~/.bashrc source ~/.bashrc # make a virtual environment for cv mkvirtualenv cv Step 4: Install OpenCV To install Open CV on the Jetson Nano, you need to build it from source. Building OpenCV from source is going to take some time, so buckle up. If you get stuck, here is another great resource which will help you compile OpenCV. Note: In some cases Python OpenCV may already be installed in your disc image. If the file exists, you can optionally copy it to your environment rather than build from source. Nvidia has said they will drop support for this, so longer term we will probably be building it. If this works: mkdir ~/mycar cp /usr/lib/python3.6/dist-packages/cv2.cpython-36m-aarch64-linux-gnu.so ~/mycar/ cd ~/mycar python -c \"import cv2\" Then you have a working version and can skip this portion of the guide. However, following the swapfile portion of this guide has made performance more predictable and solves memory thrashing. This image did not have openCV in it. The first step in building OpenCV is to define swap space on the Jetson Nano. The Jetson Nano has 4GB of RAM. This is not sufficient to build OpenCV from source. Therefore we need to define swap space on the Nano to prevent memory thrashing. # Allocates 4G of additional swap space at /var/swapfile sudo fallocate -l 4G /var/swapfile # Permissions sudo chmod 600 /var/swapfile # Make swap space sudo mkswap /var/swapfile # Turn on swap sudo swapon /var/swapfile # Automount swap space on reboot sudo bash -c 'echo \"/var/swapfile swap swap defaults 0 0\" >> /etc/fstab' # Reboot sudo reboot Now you should have enough swap space to build OpenCV. Let's setup the Jetson Nano with the pre-requisites to build OpenCV. # enter our virtual environment again workon cv # Update sudo apt-get update sudo apt-get upgrade # Pre-requisites sudo apt-get install build-essential cmake unzip pkg-config sudo apt-get install libjpeg-dev libpng-dev libtiff-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libxvidcore-dev libx264-dev sudo apt-get install libgtk-3-dev sudo apt-get install libatlas-base-dev gfortran sudo apt-get install python3-dev Now you should have all the pre-requisites you need. So, lets go ahead and download the source code for OpenCV. # Create a directory for opencv mkdir -p projects/cv2 cd projects/cv2 # Download sources wget -O opencv.zip https://github.com/opencv/opencv/archive/4.1.0.zip wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.1.0.zip # Unzip unzip opencv.zip unzip opencv_contrib.zip # Rename mv opencv-4.1.0 opencv mv opencv_contrib-4.1.0 opencv_contrib Let's get our virtual environment ( env ) ready for OpenCV. # Install Numpy pip install numpy For good measure, we'll do a reboot here. sudo reboot Now let's setup CMake correctly so it generates the correct OpenCV bindings for our virtual environment. # Create a build directory cd projects/cv2/opencv mkdir build cd build # Setup CMake cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D INSTALL_C_EXAMPLES=OFF \\ -D OPENCV_ENABLE_NONFREE=ON \\ # Contrib path -D OPENCV_EXTRA_MODULES_PATH=~/projects/cv2/opencv_contrib/modules \\ # Your virtual environment's Python executable # You need to specify the result of echo $(which python) -D PYTHON_EXECUTABLE=~/env/bin/python \\ -D BUILD_EXAMPLES=ON ../ Note: changed last line above to remove 'opencv' as it caused an error. The cmake command should show a summary of the configuration. Make sure that the Interpreter is set to the Python executable associated to your virtualenv. Note: there are several paths in the CMake setup, make sure they match where you downloaded and saved the OpenCV source. To compile the code from the build folder issue the following command. make -j2 Note: We're running full power so we can issue a -j4. This will take a while. Go grab a coffee, or watch a movie. Once the compilation is complete, you are almost done. Only a few more steps to go. # Install OpenCV sudo make install sudo ldconfig The final step is to correctly link the built OpenCV native library to your virtualenv. The native library should now be installed in a location that looks like /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.cpython-36m-xxx-linux-gnu.so . # Go to the folder where OpenCV's native library is built cd /usr/local/lib/python3.6/site-packages/cv2/python-3.6 Needed to change to code: # Rename mv cv2.cpython-36m-xxx-linux-gnu.so cv2.so # Go to your virtual environments site-packages folder cd ~/env/lib/python3.6/site-packages/ # Symlink the native library ln -s /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so cv2.so to: # Rename sudo mv cv2.cpython-36m-xxx-linux-gnu.so cv2.so # Go to your virtual environments site-packages folder cd ~/.virtualenvs/cv/lib/python3.6/site-packages/ # Symlink the native library ln -s /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so cv2.so Congratulations ! You are now done compiling OpenCV from source. A quick check to see if you did everything correctly is ls -al You should see something that looks like total 48 drwxr-xr-x 10 user user 4096 Jun 16 13:03 . drwxr-xr-x 5 user user 4096 Jun 16 07:46 .. lrwxrwxrwx 1 user user 60 Jun 16 13:03 cv2.so -> /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so -rw-r--r-- 1 user user 126 Jun 16 07:46 easy_install.py drwxr-xr-x 5 user user 4096 Jun 16 07:47 pip drwxr-xr-x 2 user user 4096 Jun 16 07:47 pip-19.1.1.dist-info drwxr-xr-x 5 user user 4096 Jun 16 07:46 pkg_resources drwxr-xr-x 2 user user 4096 Jun 16 07:46 __pycache__ drwxr-xr-x 6 user user 4096 Jun 16 07:46 setuptools drwxr-xr-x 2 user user 4096 Jun 16 07:46 setuptools-41.0.1.dist-info drwxr-xr-x 4 user user 4096 Jun 16 07:47 wheel drwxr-xr-x 2 user user 4096 Jun 16 07:47 wheel-0.33.4.dist-info To test the OpenCV installation, run python and do the following import cv2 # Should print 4.1.0 print(cv2.__version__) Step 5: Install Donkeycar Python Code Change to a dir you would like to use as the head of your projects. cd ~/projects Create a cloned workspace to build the donkeycar environment from. pip freeze >requirements.txt mkvirtualenv -r requirements.txt car # patch in the cv2 library cd ~/.virtualenvs/car/lib/python3.6/site-packages/ ln -s /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so cv2.so cd ~/projects # Set this environment to be entered on login echo \"workon car\" >>~/.bashrc Get the latest donkeycar from Github. git clone https://github.com/autorope/donkeycar cd donkeycar git checkout master pip install -e .[nano] pip install --extra-index-url https://developer.download.nvidia.com/compute/redist/jp/v42 tensorflow-gpu==1.13.1+nv19.3","title":"Software Installation"},{"location":"setup_jetson_nano.html#get-your-jetson-nano-working","text":"This block was lifted from the main donkeycar manual and annotated with the necessary changes to get the software to install. Step 1: Flash Operating System Step 2: Install Dependencies Step 3: Setup Virtual Env Step 4: Install OpenCV Step 5: Install Donkeycar Python Code","title":"Get Your Jetson Nano Working"},{"location":"setup_jetson_nano.html#step-1-flash-operating-system","text":"Visit the official Nvidia Jetson Nano Getting Started Guide . Work through the Prepare for Setup , Writing Image to the microSD Card , and Setup and First Boot instructions, then return here. The operating system flashed was r32.3.1. Setup the following: machine name: scrambler user name/password: donkey/donkey To check the software installed, ran the following command with the subsequent output: donkey@scrambler:~$ hostnamectl Static hostname: scrambler Icon name: computer Machine ID: ca67ded01f62474199a2c58cfd607d5f Boot ID: 81993f68dfcb47189da8918825844916 Operating System: Ubuntu 18.04.4 LTS Kernel: Linux 4.9.140-tegra Architecture: arm64","title":"Step 1: Flash Operating System"},{"location":"setup_jetson_nano.html#step-2-install-dependencies","text":"ssh into your vehicle. Use the the terminal for Ubuntu or Mac. Putty for windows. sudo apt-get update sudo apt-get upgrade sudo apt-get install build-essential python3 python3-dev python3-pip libhdf5-serial-dev hdf5-tools nano ntp Optionally, you can install RPi.GPIO clone for Jetson Nano from here . This is not required for default setup, but can be useful if using LED or other GPIO driven devices. This didn't, so we'll find a better procedure when this is needed.","title":"Step 2: Install Dependencies"},{"location":"setup_jetson_nano.html#step-3-setup-virtual-env","text":"The following code was changed, since it exposed a bug when installing the donkeycar code. pip3 install virtualenv python3 -m virtualenv -p python3 env --system-site-packages echo \"source env/bin/activate\" >> ~/.bashrc source ~/.bashrc The two important differences were made to the installation. Install virtualenv in system space as opposed to user space. Having this is user space was one precondition for the legacy error when installing the donkeycar system. Added virtualenvwrapper, as it provides a nicer interface. Here is a reference to using this environment. This is the code executed. # This command actually upgraded pip from what was there python3 -m pip install -U pip # sudo gives it permission to write into system space sudo -H python3 -m pip install virtualenv echo \"export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3\" >>~/.bashrc source ~/.bashrc sudo -H python3 -m pip install virtualenvwrapper mkdir $HOME/.virtualenvs echo \"export WORKON_HOME=$HOME/.virtualenvs\" >>~/.bashrc echo \"source \"`which virtualenvwrapper.sh` >>~/.bashrc source ~/.bashrc # make a virtual environment for cv mkvirtualenv cv","title":"Step 3: Setup Virtual Env"},{"location":"setup_jetson_nano.html#step-4-install-opencv","text":"To install Open CV on the Jetson Nano, you need to build it from source. Building OpenCV from source is going to take some time, so buckle up. If you get stuck, here is another great resource which will help you compile OpenCV. Note: In some cases Python OpenCV may already be installed in your disc image. If the file exists, you can optionally copy it to your environment rather than build from source. Nvidia has said they will drop support for this, so longer term we will probably be building it. If this works: mkdir ~/mycar cp /usr/lib/python3.6/dist-packages/cv2.cpython-36m-aarch64-linux-gnu.so ~/mycar/ cd ~/mycar python -c \"import cv2\" Then you have a working version and can skip this portion of the guide. However, following the swapfile portion of this guide has made performance more predictable and solves memory thrashing. This image did not have openCV in it. The first step in building OpenCV is to define swap space on the Jetson Nano. The Jetson Nano has 4GB of RAM. This is not sufficient to build OpenCV from source. Therefore we need to define swap space on the Nano to prevent memory thrashing. # Allocates 4G of additional swap space at /var/swapfile sudo fallocate -l 4G /var/swapfile # Permissions sudo chmod 600 /var/swapfile # Make swap space sudo mkswap /var/swapfile # Turn on swap sudo swapon /var/swapfile # Automount swap space on reboot sudo bash -c 'echo \"/var/swapfile swap swap defaults 0 0\" >> /etc/fstab' # Reboot sudo reboot Now you should have enough swap space to build OpenCV. Let's setup the Jetson Nano with the pre-requisites to build OpenCV. # enter our virtual environment again workon cv # Update sudo apt-get update sudo apt-get upgrade # Pre-requisites sudo apt-get install build-essential cmake unzip pkg-config sudo apt-get install libjpeg-dev libpng-dev libtiff-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libxvidcore-dev libx264-dev sudo apt-get install libgtk-3-dev sudo apt-get install libatlas-base-dev gfortran sudo apt-get install python3-dev Now you should have all the pre-requisites you need. So, lets go ahead and download the source code for OpenCV. # Create a directory for opencv mkdir -p projects/cv2 cd projects/cv2 # Download sources wget -O opencv.zip https://github.com/opencv/opencv/archive/4.1.0.zip wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.1.0.zip # Unzip unzip opencv.zip unzip opencv_contrib.zip # Rename mv opencv-4.1.0 opencv mv opencv_contrib-4.1.0 opencv_contrib Let's get our virtual environment ( env ) ready for OpenCV. # Install Numpy pip install numpy For good measure, we'll do a reboot here. sudo reboot Now let's setup CMake correctly so it generates the correct OpenCV bindings for our virtual environment. # Create a build directory cd projects/cv2/opencv mkdir build cd build # Setup CMake cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D INSTALL_C_EXAMPLES=OFF \\ -D OPENCV_ENABLE_NONFREE=ON \\ # Contrib path -D OPENCV_EXTRA_MODULES_PATH=~/projects/cv2/opencv_contrib/modules \\ # Your virtual environment's Python executable # You need to specify the result of echo $(which python) -D PYTHON_EXECUTABLE=~/env/bin/python \\ -D BUILD_EXAMPLES=ON ../ Note: changed last line above to remove 'opencv' as it caused an error. The cmake command should show a summary of the configuration. Make sure that the Interpreter is set to the Python executable associated to your virtualenv. Note: there are several paths in the CMake setup, make sure they match where you downloaded and saved the OpenCV source. To compile the code from the build folder issue the following command. make -j2 Note: We're running full power so we can issue a -j4. This will take a while. Go grab a coffee, or watch a movie. Once the compilation is complete, you are almost done. Only a few more steps to go. # Install OpenCV sudo make install sudo ldconfig The final step is to correctly link the built OpenCV native library to your virtualenv. The native library should now be installed in a location that looks like /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.cpython-36m-xxx-linux-gnu.so . # Go to the folder where OpenCV's native library is built cd /usr/local/lib/python3.6/site-packages/cv2/python-3.6 Needed to change to code: # Rename mv cv2.cpython-36m-xxx-linux-gnu.so cv2.so # Go to your virtual environments site-packages folder cd ~/env/lib/python3.6/site-packages/ # Symlink the native library ln -s /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so cv2.so to: # Rename sudo mv cv2.cpython-36m-xxx-linux-gnu.so cv2.so # Go to your virtual environments site-packages folder cd ~/.virtualenvs/cv/lib/python3.6/site-packages/ # Symlink the native library ln -s /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so cv2.so Congratulations ! You are now done compiling OpenCV from source. A quick check to see if you did everything correctly is ls -al You should see something that looks like total 48 drwxr-xr-x 10 user user 4096 Jun 16 13:03 . drwxr-xr-x 5 user user 4096 Jun 16 07:46 .. lrwxrwxrwx 1 user user 60 Jun 16 13:03 cv2.so -> /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so -rw-r--r-- 1 user user 126 Jun 16 07:46 easy_install.py drwxr-xr-x 5 user user 4096 Jun 16 07:47 pip drwxr-xr-x 2 user user 4096 Jun 16 07:47 pip-19.1.1.dist-info drwxr-xr-x 5 user user 4096 Jun 16 07:46 pkg_resources drwxr-xr-x 2 user user 4096 Jun 16 07:46 __pycache__ drwxr-xr-x 6 user user 4096 Jun 16 07:46 setuptools drwxr-xr-x 2 user user 4096 Jun 16 07:46 setuptools-41.0.1.dist-info drwxr-xr-x 4 user user 4096 Jun 16 07:47 wheel drwxr-xr-x 2 user user 4096 Jun 16 07:47 wheel-0.33.4.dist-info To test the OpenCV installation, run python and do the following import cv2 # Should print 4.1.0 print(cv2.__version__)","title":"Step 4: Install OpenCV"},{"location":"setup_jetson_nano.html#step-5-install-donkeycar-python-code","text":"Change to a dir you would like to use as the head of your projects. cd ~/projects Create a cloned workspace to build the donkeycar environment from. pip freeze >requirements.txt mkvirtualenv -r requirements.txt car # patch in the cv2 library cd ~/.virtualenvs/car/lib/python3.6/site-packages/ ln -s /usr/local/lib/python3.6/site-packages/cv2/python-3.6/cv2.so cv2.so cd ~/projects # Set this environment to be entered on login echo \"workon car\" >>~/.bashrc Get the latest donkeycar from Github. git clone https://github.com/autorope/donkeycar cd donkeycar git checkout master pip install -e .[nano] pip install --extra-index-url https://developer.download.nvidia.com/compute/redist/jp/v42 tensorflow-gpu==1.13.1+nv19.3","title":"Step 5: Install Donkeycar Python Code"},{"location":"finalassy/batteryprep.html","text":"Install Charge Cable Protectors Place the charging cable protector on each battery. There is a 3-wire protector for the 2S battery and a 4-wire protector for the 3S battery. These protectors give you something to grab when plugging in the charging cable as well as they hold the cable in-place while the car is running. The protector has slots for the connector to slide into as well as wire guides on the back side.","title":"Battery Prep"},{"location":"finalassy/batteryprep.html#install-charge-cable-protectors","text":"Place the charging cable protector on each battery. There is a 3-wire protector for the 2S battery and a 4-wire protector for the 3S battery. These protectors give you something to grab when plugging in the charging cable as well as they hold the cable in-place while the car is running. The protector has slots for the connector to slide into as well as wire guides on the back side.","title":"Install Charge Cable Protectors"},{"location":"finalassy/cameramount.html","text":"Raspberry Pi (CSI) Camera Mount Camera Cable Connection The CSI cable connector is very fragile, so extreme care must be taken while inserting the cable. JetsonHacks has a good demonstration of this process. Following the JetsonHacks advice, insert the camera cable into the Jetson Nano as shown. Chassis Mount The camera fixture simply slips into the camera mount on the front of the car. Squeeze the latching clips together while inserting the camera. When fully inserted, a click will be heard.","title":"Camera Mount"},{"location":"finalassy/cameramount.html#raspberry-pi-csi-camera-mount","text":"","title":"Raspberry Pi (CSI) Camera Mount"},{"location":"finalassy/cameramount.html#camera-cable-connection","text":"The CSI cable connector is very fragile, so extreme care must be taken while inserting the cable. JetsonHacks has a good demonstration of this process. Following the JetsonHacks advice, insert the camera cable into the Jetson Nano as shown.","title":"Camera Cable Connection"},{"location":"finalassy/cameramount.html#chassis-mount","text":"The camera fixture simply slips into the camera mount on the front of the car. Squeeze the latching clips together while inserting the camera. When fully inserted, a click will be heard.","title":"Chassis Mount"},{"location":"finalassy/drivebattery.html","text":"Remove Battery Holder Remove the battery holder on the left side of the car chassis. It is held in place by two spring clips. The clip on the front is tagged with a piece of red tape. This clip is special. It had to be shortened slightly so it would not come in contact with the steeringcolumn behind it. The original car had this post turned 90 degrees, but the flange at the bottom of the post got in the way of inserting the LiPo battery. The LiPo battery is a little larger than the original NiMH battery and thus the need for a whole new battery holder. Install Battery in Holder Insert the 2S battery (1.8Ah) in the battery holder. This can be a little tricky as the wires want to bind up on the front of the holder. Insert Assembly in Car Insert the battery and holder back into the car and secure with the clip pins. Secure the charging cable into the slot on the side of the battery holder.","title":"Install Drive Battery"},{"location":"finalassy/drivebattery.html#remove-battery-holder","text":"Remove the battery holder on the left side of the car chassis. It is held in place by two spring clips. The clip on the front is tagged with a piece of red tape. This clip is special. It had to be shortened slightly so it would not come in contact with the steeringcolumn behind it. The original car had this post turned 90 degrees, but the flange at the bottom of the post got in the way of inserting the LiPo battery. The LiPo battery is a little larger than the original NiMH battery and thus the need for a whole new battery holder.","title":"Remove Battery Holder"},{"location":"finalassy/drivebattery.html#install-battery-in-holder","text":"Insert the 2S battery (1.8Ah) in the battery holder. This can be a little tricky as the wires want to bind up on the front of the holder.","title":"Install Battery in Holder"},{"location":"finalassy/drivebattery.html#insert-assembly-in-car","text":"Insert the battery and holder back into the car and secure with the clip pins. Secure the charging cable into the slot on the side of the battery holder.","title":"Insert Assembly in Car"},{"location":"finalassy/finalhookup.html","text":"Connecting Car Top to Chassis The car top contains the bulk of the electronics. Only a few connections are needed before securing to the chassis. To aid in the connection process, a small 2x4 is handy to support the car top. Connect PWM Wires Position the car top on the right tires and block of wood as shown. Connect the drive motor control wires to PWM Port 0. This is the 3-wire cable that is white/red/black. The black lead (gnd) goes to the outside edge of the circuit board. Connect the steering servo cable (yellow/orange/brown) to PWM Port 1. The brown lead (gnd) connects to the outside edge of the circuit board. Connect Power Wires Connect the motor controller power lead (mini tamiya connector) to the right car panel. Connect the Drive Battery (XT-60 connector) to the right control panel. Mount Top to Chassis Carfully roll car top over and position any hanging wires to the center of the car. Insert car top on chassis mounting posts. Secure with four bent clips.","title":"Final Hook Up"},{"location":"finalassy/finalhookup.html#connecting-car-top-to-chassis","text":"The car top contains the bulk of the electronics. Only a few connections are needed before securing to the chassis. To aid in the connection process, a small 2x4 is handy to support the car top.","title":"Connecting Car Top to Chassis"},{"location":"finalassy/finalhookup.html#connect-pwm-wires","text":"Position the car top on the right tires and block of wood as shown. Connect the drive motor control wires to PWM Port 0. This is the 3-wire cable that is white/red/black. The black lead (gnd) goes to the outside edge of the circuit board. Connect the steering servo cable (yellow/orange/brown) to PWM Port 1. The brown lead (gnd) connects to the outside edge of the circuit board.","title":"Connect PWM Wires"},{"location":"finalassy/finalhookup.html#connect-power-wires","text":"Connect the motor controller power lead (mini tamiya connector) to the right car panel. Connect the Drive Battery (XT-60 connector) to the right control panel.","title":"Connect Power Wires"},{"location":"finalassy/finalhookup.html#mount-top-to-chassis","text":"Carfully roll car top over and position any hanging wires to the center of the car. Insert car top on chassis mounting posts. Secure with four bent clips.","title":"Mount Top to Chassis"},{"location":"finalassy/introduction.html","text":"There are several steps to finish the car assembly: Prepare Batteries Install Drive Battery Install Processor Battery Test Processor Regulator Mount Camera Assemble Roll Bars Final Hookup","title":"Introduction"},{"location":"finalassy/processorbattery.html","text":"I2C Control Cable Take note of how the I2C Control Cable is plugged in to the Jetson Nano. It plugs into the outter row of pins with the gap between wires to the right. Unplug this cable. Pull the four clip pins holding the processor mounting plate in place. Note, one pin is shown in the picture. Insert Battery into Holder Rotate the processor out of the way. Slip the processor battery cables down through the slot in teh front of the car. Slide battery into slot. Reinstall Processor Plate Rotate mounting plate back into place. Secure with four clip pins. Reconnect the I2C Control Cable. Connect Power Cable Insure power switches are off. Turn processor assembly upside down. Route the processor battery cable under the 5V cable as shown. Mate the two XT-60 connectors. Place the battery wire under the retaining clip as shown. Stow Charging Cable Flip assembly right side up again. Place the charging cable in the slot on the left side of the car.","title":"Install Processor Battery"},{"location":"finalassy/processorbattery.html#i2c-control-cable","text":"Take note of how the I2C Control Cable is plugged in to the Jetson Nano. It plugs into the outter row of pins with the gap between wires to the right. Unplug this cable. Pull the four clip pins holding the processor mounting plate in place. Note, one pin is shown in the picture.","title":"I2C Control Cable"},{"location":"finalassy/processorbattery.html#insert-battery-into-holder","text":"Rotate the processor out of the way. Slip the processor battery cables down through the slot in teh front of the car. Slide battery into slot.","title":"Insert Battery into Holder"},{"location":"finalassy/processorbattery.html#reinstall-processor-plate","text":"Rotate mounting plate back into place. Secure with four clip pins. Reconnect the I2C Control Cable.","title":"Reinstall Processor Plate"},{"location":"finalassy/processorbattery.html#connect-power-cable","text":"Insure power switches are off. Turn processor assembly upside down. Route the processor battery cable under the 5V cable as shown. Mate the two XT-60 connectors. Place the battery wire under the retaining clip as shown.","title":"Connect Power Cable"},{"location":"finalassy/processorbattery.html#stow-charging-cable","text":"Flip assembly right side up again. Place the charging cable in the slot on the left side of the car.","title":"Stow Charging Cable"},{"location":"finalassy/rollbarassembly.html","text":"Roll Bar The roll bar assembly consists of a left and right roll bar with a support cross piece. Six screws connect it all together and to the car. Quantity Part Notes 1 Left Roll Bar 1 Right Roll Bar 1 Roll Bar Support 6 3M x 14mm screws Assemble Roll Bars Connect the two roll bars together with the support cross piece and two screws. Attach to Car Place the roll bars upside down. Invert the car top and set on bars as shown. Note: the most vertical part of the roll bar goes toward the front of the car. This provides the most protection for the camera. Attach with four screws. Completed Roll Bar Assembly.","title":"Roll Bar Assembly"},{"location":"finalassy/rollbarassembly.html#roll-bar","text":"The roll bar assembly consists of a left and right roll bar with a support cross piece. Six screws connect it all together and to the car. Quantity Part Notes 1 Left Roll Bar 1 Right Roll Bar 1 Roll Bar Support 6 3M x 14mm screws","title":"Roll Bar"},{"location":"finalassy/rollbarassembly.html#assemble-roll-bars","text":"Connect the two roll bars together with the support cross piece and two screws.","title":"Assemble Roll Bars"},{"location":"finalassy/rollbarassembly.html#attach-to-car","text":"Place the roll bars upside down. Invert the car top and set on bars as shown. Note: the most vertical part of the roll bar goes toward the front of the car. This provides the most protection for the camera. Attach with four screws. Completed Roll Bar Assembly.","title":"Attach to Car"},{"location":"finalassy/testvoltageregulator.html","text":"Voltage Regulator The voltage regulator takes the processor battery input (nominally 11.1V), drops it down to 5V for drive the processor. This is a high efficiency convertor (around 98%) so minimal power is lost during this process. Testing The regulator has been adjusted to appropriate levels before shipping. This test uses the display readout to check the output voltage level. This check is to insure proper levels after shipping before before applying power to the processor. Unplug 5V power cable on the processor (should already be unplugged). Turn on computer power switch on the processor panel. With regulator control buttons, select the display of the output voltage. Repeatedly press SET button until F-0 mode appears on display Press ENT button The display should read between 5.2 and 5.4 volts. If not, with a small screw driver, adjust the V control under the display until the reading is within this range. Set the readout back to displaying input voltage. Repeatedly press SET button until F-1 mode appears on display Press ENT button Turn off the power switch. Plug the power cable back into the processor. Should a full calibration of the regulator be required, refer to the Drok Calibration Sheet for full details. This will require a DMM with current measuring capability along with a resistive power load.","title":"Test Voltage Regulator"},{"location":"finalassy/testvoltageregulator.html#voltage-regulator","text":"The voltage regulator takes the processor battery input (nominally 11.1V), drops it down to 5V for drive the processor. This is a high efficiency convertor (around 98%) so minimal power is lost during this process.","title":"Voltage Regulator"},{"location":"finalassy/testvoltageregulator.html#testing","text":"The regulator has been adjusted to appropriate levels before shipping. This test uses the display readout to check the output voltage level. This check is to insure proper levels after shipping before before applying power to the processor. Unplug 5V power cable on the processor (should already be unplugged). Turn on computer power switch on the processor panel. With regulator control buttons, select the display of the output voltage. Repeatedly press SET button until F-0 mode appears on display Press ENT button The display should read between 5.2 and 5.4 volts. If not, with a small screw driver, adjust the V control under the display until the reading is within this range. Set the readout back to displaying input voltage. Repeatedly press SET button until F-1 mode appears on display Press ENT button Turn off the power switch. Plug the power cable back into the processor. Should a full calibration of the regulator be required, refer to the Drok Calibration Sheet for full details. This will require a DMM with current measuring capability along with a resistive power load.","title":"Testing"},{"location":"hwassy/cableprep.html","text":"Computer Regulator Cable Construction Three cables are needed to connect the battery through the power switch, regulator and processor. Refer to the following pictures to construct the computer power regulator cable. Battery to Power Switch Cable Cut 8\" of 18AWG Red/Black Zip Cord. Cut the red lead down to 6.5\" Strip 0.4\" insulation from each end of the wires. Solder the wires on the XT60 Male Connector with the heat shrink tubing. Crimp the right angle spade connector to the shortened end of the red wire. Crimp the ferrule on the black wire. Power Switch to Regulator Cable Cut 3.5\" 18AWG Red wire. Strip 0.4\" from each end. Crimp the right angle spade connector to one end of the red wire. Crimp the ferrule on the other end. Regulator to Computer Cable Cut 2\" of 18AWG Red/Black Zip Cord. Strip 0.4\" insulation from each end of the wires. Crimp the ferrules on each end of each wire. Screw ferrules on one end of the wire into the male barrel jack. Drive System Cable I2C Drive System Control Cable Slip 1.5\" heat shrink tubing over four 6.5\" connector wires with female crimp connectors. Insert each wire into 1x5 Pin housing. The wires go into pins 1,2,3,5. The wire ordering is the same for each end. Note pin 4 slot is unused. Heat the tubing so to tighly constrain the wires. Voltmeter Cable Prep","title":"Cable Preparation"},{"location":"hwassy/cableprep.html#computer-regulator-cable-construction","text":"Three cables are needed to connect the battery through the power switch, regulator and processor. Refer to the following pictures to construct the computer power regulator cable.","title":"Computer Regulator Cable Construction"},{"location":"hwassy/cableprep.html#battery-to-power-switch-cable","text":"Cut 8\" of 18AWG Red/Black Zip Cord. Cut the red lead down to 6.5\" Strip 0.4\" insulation from each end of the wires. Solder the wires on the XT60 Male Connector with the heat shrink tubing. Crimp the right angle spade connector to the shortened end of the red wire. Crimp the ferrule on the black wire.","title":"Battery to Power Switch Cable"},{"location":"hwassy/cableprep.html#power-switch-to-regulator-cable","text":"Cut 3.5\" 18AWG Red wire. Strip 0.4\" from each end. Crimp the right angle spade connector to one end of the red wire. Crimp the ferrule on the other end.","title":"Power Switch to Regulator Cable"},{"location":"hwassy/cableprep.html#regulator-to-computer-cable","text":"Cut 2\" of 18AWG Red/Black Zip Cord. Strip 0.4\" insulation from each end of the wires. Crimp the ferrules on each end of each wire. Screw ferrules on one end of the wire into the male barrel jack.","title":"Regulator to Computer Cable"},{"location":"hwassy/cableprep.html#drive-system-cable","text":"","title":"Drive System Cable"},{"location":"hwassy/cableprep.html#i2c-drive-system-control-cable","text":"Slip 1.5\" heat shrink tubing over four 6.5\" connector wires with female crimp connectors. Insert each wire into 1x5 Pin housing. The wires go into pins 1,2,3,5. The wire ordering is the same for each end. Note pin 4 slot is unused. Heat the tubing so to tighly constrain the wires.","title":"I2C Drive System Control Cable"},{"location":"hwassy/cableprep.html#voltmeter-cable-prep","text":"","title":"Voltmeter Cable Prep"},{"location":"hwassy/hwassy.html","text":"Indroduction This section is a work in progress. Not all pictures will be of the current design and may contain different colors. As this effort completes, there should be a uniform presentation from beginning to end. Processor Panel The processor panel houses the power regulator for the processor and handles cabling between the battery and processor. The following parts are used for construction: Quantity Part Notes 1 3D printed Power Panel 1 Battery to Switch Cable Constructed in previous section 1 Switch to regulator cable Constructed in previous section 1 Power Regulator Drok Buck Converter 180080 2 Switch caps Included with power regulator module 1 Power Switch Rocker Switch 20A 125V 4 M2.5 x 8 mm self tapping screws On the 3D printed part, clean out the four regulator board mounting holes with a 5/64\" drill bit. Clean out the two panel mounting holes with a 1/8\" bit. Place the switch Caps in the rectangular mounting holes in the panel. Mount the regulator to the panel with four 3M x 5 mm screws. Connect the ground lead of the battery to switch cable to the negative input terminal on the regulator as shown. Connect the Switch to Regulator cable to the positive input terminal as shown. Mount the power switch in the panel. Connect the cables as shown. Connecting Processor Panel to Base Quantity Part Notes 1 3D Printed Base Plate 1 Assembled Processor Panel 2 M3 x 24 mm screws 2 M3 nyloc nuts Clean out the eight small mounting holes in the base plate with a 1/8\" drill bit. Connect processor panel to base plate with two M3 x 24 mm screws and nuts. Drive System Panel Quantity Part Notes 1 3D printed Drive System Panel 1 Power Cable Constructed in previous section 1 PWM Control Cable Constructed in previous section 1 Panel Voltmeter Adafruit mini 2-wire voltmeter as prepared in previous section 1 PWM Servo Controller PCA9685 12 Bit Servo Driver 1 Power Switch Rocker Switch 20A 125V 4 M2.5 x 8 mm self tapping screws 2 M2 x 5 mm self tapping screws Clean out the four PWM module mounting holes in the Drive System Panel with a 5/64\" bit. Clean out the two voltmeter mounting holes in the Drive System Panel with a 1/16\" bit. Mount the servo controller as shown with four M2.5 x 8 mm screws. Mount the voltmeter with two M2 x 5 mm screws. Insert the power switch as shown. Connect the PWM Control Cable as shown. The side with the gap between the wires goes to the top of the connector on the PWM board (gnd). Connect the power cable to the power switch and voltmeter as shown. Push on the connector to bend the lugs on teh power switch upwards. This will provide proper clearance between the power switch and the car motor. Connecting Drive System Panel to Base Quantity Part Notes 1 3D Printed Base Plate 1 Assembled Drive System Panel 2 M3 x 24 mm screws 2 M3 nyloc nuts Route the PWM Cable through the base slot as shown. Connect Drive System panel to base plate with two M3 x 24 mm screws and nuts. Processor Mount Plate Attachment Clean out processor mounting hole on processor mounting plate with 5/64\" drill bit. Place the Processor Mounting Plate on top as shown to enclose the battery. Secure with 4 bent clip pins. 5V Barrell Cable Attachment Quantity Part Notes 1 3D Printed Assembly 1 Assembled 5V Power Cable 1 5V Extension Cable Insert straight round end into the large round hole in the top of the chassis. Screw the ferrules on the end of the assembled 5V power cable into the output of the regulator. Plug the barrell jack on the other end into the extension cable","title":"Hardware Assembly"},{"location":"hwassy/hwassy.html#indroduction","text":"This section is a work in progress. Not all pictures will be of the current design and may contain different colors. As this effort completes, there should be a uniform presentation from beginning to end.","title":"Indroduction"},{"location":"hwassy/hwassy.html#processor-panel","text":"The processor panel houses the power regulator for the processor and handles cabling between the battery and processor. The following parts are used for construction: Quantity Part Notes 1 3D printed Power Panel 1 Battery to Switch Cable Constructed in previous section 1 Switch to regulator cable Constructed in previous section 1 Power Regulator Drok Buck Converter 180080 2 Switch caps Included with power regulator module 1 Power Switch Rocker Switch 20A 125V 4 M2.5 x 8 mm self tapping screws On the 3D printed part, clean out the four regulator board mounting holes with a 5/64\" drill bit. Clean out the two panel mounting holes with a 1/8\" bit. Place the switch Caps in the rectangular mounting holes in the panel. Mount the regulator to the panel with four 3M x 5 mm screws. Connect the ground lead of the battery to switch cable to the negative input terminal on the regulator as shown. Connect the Switch to Regulator cable to the positive input terminal as shown. Mount the power switch in the panel. Connect the cables as shown.","title":"Processor Panel"},{"location":"hwassy/hwassy.html#connecting-processor-panel-to-base","text":"Quantity Part Notes 1 3D Printed Base Plate 1 Assembled Processor Panel 2 M3 x 24 mm screws 2 M3 nyloc nuts Clean out the eight small mounting holes in the base plate with a 1/8\" drill bit. Connect processor panel to base plate with two M3 x 24 mm screws and nuts.","title":"Connecting Processor Panel to Base"},{"location":"hwassy/hwassy.html#drive-system-panel","text":"Quantity Part Notes 1 3D printed Drive System Panel 1 Power Cable Constructed in previous section 1 PWM Control Cable Constructed in previous section 1 Panel Voltmeter Adafruit mini 2-wire voltmeter as prepared in previous section 1 PWM Servo Controller PCA9685 12 Bit Servo Driver 1 Power Switch Rocker Switch 20A 125V 4 M2.5 x 8 mm self tapping screws 2 M2 x 5 mm self tapping screws Clean out the four PWM module mounting holes in the Drive System Panel with a 5/64\" bit. Clean out the two voltmeter mounting holes in the Drive System Panel with a 1/16\" bit. Mount the servo controller as shown with four M2.5 x 8 mm screws. Mount the voltmeter with two M2 x 5 mm screws. Insert the power switch as shown. Connect the PWM Control Cable as shown. The side with the gap between the wires goes to the top of the connector on the PWM board (gnd). Connect the power cable to the power switch and voltmeter as shown. Push on the connector to bend the lugs on teh power switch upwards. This will provide proper clearance between the power switch and the car motor.","title":"Drive System Panel"},{"location":"hwassy/hwassy.html#connecting-drive-system-panel-to-base","text":"Quantity Part Notes 1 3D Printed Base Plate 1 Assembled Drive System Panel 2 M3 x 24 mm screws 2 M3 nyloc nuts Route the PWM Cable through the base slot as shown. Connect Drive System panel to base plate with two M3 x 24 mm screws and nuts.","title":"Connecting Drive System Panel to Base"},{"location":"hwassy/hwassy.html#processor-mount-plate-attachment","text":"Clean out processor mounting hole on processor mounting plate with 5/64\" drill bit. Place the Processor Mounting Plate on top as shown to enclose the battery. Secure with 4 bent clip pins.","title":"Processor Mount Plate Attachment"},{"location":"hwassy/hwassy.html#5v-barrell-cable-attachment","text":"Quantity Part Notes 1 3D Printed Assembly 1 Assembled 5V Power Cable 1 5V Extension Cable Insert straight round end into the large round hole in the top of the chassis. Screw the ferrules on the end of the assembled 5V power cable into the output of the regulator. Plug the barrell jack on the other end into the extension cable","title":"5V Barrell Cable Attachment"},{"location":"hwassy/introduction.html","text":"The principle goal of this project was to enhance the donkey car so that more useful and productive time can be obtained while the car and processor are operating fully off batteries. To hold the necessary electronics three layers of printed materials form a sandwich that is mounted to the chassis. The center layer is the base layer from which the other components are mounted. Below this base layer are the two side panels. These panels are bolted to the base with M3x24mm screws with nyloc nuts. Bolts and nuts are used here so that we don't rely on integrety of the Z-axis filament strength to hold things together. The left side panel, houses the power switch and voltage regulator for the processor. The right side panel, houses a power switch, panel voltmeter and the servo controller for the drive system. These two panels together form a cavity for holding the computer battery which is a 3 cell LiPo battery. Above the center or base layer is mounted the processor and camera mounting board. This layer finishes the enclosure of the processor battery. To make battery access easy, this layer is held in place by bent spring clips that are used in several places on the car.","title":"Introduction"},{"location":"hwdesign/cameramount.html","text":"Camera Differences Two main camera types are Specified for use with the Jetson Nano. For the jetbot construction, one option is to use a Raspberry Pi Camera V2 along with a wide angle camera lense attachment. Another is a camera from Lenard Imaging. A camera specified for the donkeycar is the Sainsmart Wide Angle Camera for the Raspberry Pi. The Sainsmart and Lenard Imaging cameras have the same construction which is different than the Raspberry Camera. The following picture shows a side-by-side comparision of the two. The camera on the left is the Raspberry PI Camera with the wide angle lense attachment and the one on the right is the Sainsmart camera. The Raspberry Pi Camera has circuitry on the back of the board which sticks up around 3mm, so any mounting fixture will require standoffs to account for this. The cable connector also is mounted to the back of the board. The Sainsmart Camera has the circuitrty on the front of the board along with the cable connector. The back of the board only has two small screws which stick up only 1mm. The most significant difference is because the connectors are mounted on opposite sids of the board, the cable gets plugged in 180 degrees different. This means that in one implentation the cable will either require a twist to plug it into the nano, or be routed over the top of the camera. A twist in the cable is certainly doable, but it is rather unsightly in an otherwise clean design. Caution on Cameras Not all Pi Cameras work on the Jetson Nano, even ones linked by reputable references. Instead of looking to be general in what camera to use, we'll restrict the camera mount to only address a known working camera. This camera is the RPi Camera V2 and for wide angle lenses, use the 160-degree FoV .","title":"Camera Mount"},{"location":"hwdesign/cameramount.html#camera-differences","text":"Two main camera types are Specified for use with the Jetson Nano. For the jetbot construction, one option is to use a Raspberry Pi Camera V2 along with a wide angle camera lense attachment. Another is a camera from Lenard Imaging. A camera specified for the donkeycar is the Sainsmart Wide Angle Camera for the Raspberry Pi. The Sainsmart and Lenard Imaging cameras have the same construction which is different than the Raspberry Camera. The following picture shows a side-by-side comparision of the two. The camera on the left is the Raspberry PI Camera with the wide angle lense attachment and the one on the right is the Sainsmart camera. The Raspberry Pi Camera has circuitry on the back of the board which sticks up around 3mm, so any mounting fixture will require standoffs to account for this. The cable connector also is mounted to the back of the board. The Sainsmart Camera has the circuitrty on the front of the board along with the cable connector. The back of the board only has two small screws which stick up only 1mm. The most significant difference is because the connectors are mounted on opposite sids of the board, the cable gets plugged in 180 degrees different. This means that in one implentation the cable will either require a twist to plug it into the nano, or be routed over the top of the camera. A twist in the cable is certainly doable, but it is rather unsightly in an otherwise clean design.","title":"Camera Differences"},{"location":"hwdesign/cameramount.html#caution-on-cameras","text":"Not all Pi Cameras work on the Jetson Nano, even ones linked by reputable references. Instead of looking to be general in what camera to use, we'll restrict the camera mount to only address a known working camera. This camera is the RPi Camera V2 and for wide angle lenses, use the 160-degree FoV .","title":"Caution on Cameras"},{"location":"hwdesign/enhancements.html","text":"Enhancements To make the car easier to use and facilitate training, a few enhancements were added to the basic car. The power switch for the ESC is buried in the middle of the car, so a power switch was added to the side of the car. To monitor the state of the car battery, a mini-panel voltmeter was added. When running off the battery, only reduced power is available for the Jetson Nano. A separate LiPo battery along with a power regulator was added so the processor can be run at full power. Swapped the NiMH battery for a LiPo for longer run times. This battery was slightly bigger so the battery holder needed adjusting. These issues can all be addressed by redesigning the 3D printed material to accomodate appropriate battery holders and a power panels for controlling and monitoring battery levels. Design Notes The rest of this section contains notes on the thoughts that went into modifying this car.","title":"Enhancements"},{"location":"hwdesign/enhancements.html#enhancements","text":"To make the car easier to use and facilitate training, a few enhancements were added to the basic car. The power switch for the ESC is buried in the middle of the car, so a power switch was added to the side of the car. To monitor the state of the car battery, a mini-panel voltmeter was added. When running off the battery, only reduced power is available for the Jetson Nano. A separate LiPo battery along with a power regulator was added so the processor can be run at full power. Swapped the NiMH battery for a LiPo for longer run times. This battery was slightly bigger so the battery holder needed adjusting. These issues can all be addressed by redesigning the 3D printed material to accomodate appropriate battery holders and a power panels for controlling and monitoring battery levels.","title":"Enhancements"},{"location":"hwdesign/enhancements.html#design-notes","text":"The rest of this section contains notes on the thoughts that went into modifying this car.","title":"Design Notes"},{"location":"hwdesign/mountingparts.html","text":"Screws The 3D printed parts and electronics will be held together by screws. Self threading screws are the most desireable since they take the least post printing effort for mounting. For the small screws here, sheet metal screws usually work well, however, screws designed for threading plastic have some advantages. Plastic thread forming screws have sharply angled threads that require less driving force and are less likely to crack the plastic. There many vendors for screws on the web. Only a few have a good selection of screws designed for plastic. McMaster-Carr, has a wide selection and good shipping times. The only down side is that they tend to be expensive. Most of their smaller screws come with torx heads. Torx allows you to apply extra force with less slippage or damage to the recess than the most common philips head. Again, the downside to this, is that not everyone has access to small torx screw drivers. Nonetheless, this is the chosen screw for putting this robot together. Circuit Board Mounting Requirements Each circuit board or piece of hardware has different sized mounting holes. Some consolidation of sizes could take place, but for the initial pass, appropriate sized scres were used for each. The following lists the measurements component. Item Hole Size Length Camera 2.1mm 5mm Volt Meter 2.0mm 4mm Servo Contoller 2.6mm 5mm Regulator 3.1mm 4mm Jetson Nano 2.7mm 8mm To minimize the screw varieties, the selected screws with their parameters are outlined below: Item Screw (mm) Drive Size Head Size dia / ht (mm) Drill Size (mm) Bit to Clean Printed Hole Camera Voltmeter M2 x 5 self tapping T6 3.35 / 1.6 #52 - 1.6129 1/16\" Servo Controller Jetson Nano Regulator M2.5 x 8 self tapping T8 4.25 / 1.9 #45 - 2.0808 5/64\" Roll Bar M3 x 16 self tapping T10 5.15 / 2.3 #41 - 2.4384 3/32\" Board Sandwich M3 x 24 T10 5.15 / 2.3 3.0 1/8\" Even tough the 3D printer has parameters to control the amount of horizontal expansion, when printing small holes, there is always some extra expansion or imperfections, so using a drill bit to clean out a printed hole makes inserting screws much easier. SAE bits are more common, so the above right table column lists the bit to use for cleaingn out the printed holes. 3D Printed Sandwich Mounting Three layers of printed materials form a sandwich that is mounted to the chassis. The center layer is the base layer from which the other components are mounted. Below this layer are the two side panels. These panels are bolted to the base with M3x24mm screws with nyloc nuts. Bolts and nuts are used here so that we don't rely on integrety of the Z-axis filament strength to hold things together. Above the center layer is mounted the processor and camera mount board. This layer encloses the processor battery. To make battery access easy, this layer is held in place by bent spring clips that are used in several places on the car. Mounting to the Chassis There are four mounting points where the car top (which is removed) is attached.The sandwich mounts to these points with the same bent spring clips. Mounting the Camera A useful feature might be to have a pan and tilt camera on the car. The full implementation of this will take place later, but there is sufficient room to mount the Adafruit Pan/Tilt mechanism. The camera mount location is based on this mechanism's requirements. A 3D print of a fixed camera will use these mounting points.","title":"Mounting Parts"},{"location":"hwdesign/mountingparts.html#screws","text":"The 3D printed parts and electronics will be held together by screws. Self threading screws are the most desireable since they take the least post printing effort for mounting. For the small screws here, sheet metal screws usually work well, however, screws designed for threading plastic have some advantages. Plastic thread forming screws have sharply angled threads that require less driving force and are less likely to crack the plastic. There many vendors for screws on the web. Only a few have a good selection of screws designed for plastic. McMaster-Carr, has a wide selection and good shipping times. The only down side is that they tend to be expensive. Most of their smaller screws come with torx heads. Torx allows you to apply extra force with less slippage or damage to the recess than the most common philips head. Again, the downside to this, is that not everyone has access to small torx screw drivers. Nonetheless, this is the chosen screw for putting this robot together.","title":"Screws"},{"location":"hwdesign/mountingparts.html#circuit-board-mounting-requirements","text":"Each circuit board or piece of hardware has different sized mounting holes. Some consolidation of sizes could take place, but for the initial pass, appropriate sized scres were used for each. The following lists the measurements component. Item Hole Size Length Camera 2.1mm 5mm Volt Meter 2.0mm 4mm Servo Contoller 2.6mm 5mm Regulator 3.1mm 4mm Jetson Nano 2.7mm 8mm To minimize the screw varieties, the selected screws with their parameters are outlined below: Item Screw (mm) Drive Size Head Size dia / ht (mm) Drill Size (mm) Bit to Clean Printed Hole Camera Voltmeter M2 x 5 self tapping T6 3.35 / 1.6 #52 - 1.6129 1/16\" Servo Controller Jetson Nano Regulator M2.5 x 8 self tapping T8 4.25 / 1.9 #45 - 2.0808 5/64\" Roll Bar M3 x 16 self tapping T10 5.15 / 2.3 #41 - 2.4384 3/32\" Board Sandwich M3 x 24 T10 5.15 / 2.3 3.0 1/8\" Even tough the 3D printer has parameters to control the amount of horizontal expansion, when printing small holes, there is always some extra expansion or imperfections, so using a drill bit to clean out a printed hole makes inserting screws much easier. SAE bits are more common, so the above right table column lists the bit to use for cleaingn out the printed holes.","title":"Circuit Board Mounting Requirements"},{"location":"hwdesign/mountingparts.html#3d-printed-sandwich-mounting","text":"Three layers of printed materials form a sandwich that is mounted to the chassis. The center layer is the base layer from which the other components are mounted. Below this layer are the two side panels. These panels are bolted to the base with M3x24mm screws with nyloc nuts. Bolts and nuts are used here so that we don't rely on integrety of the Z-axis filament strength to hold things together. Above the center layer is mounted the processor and camera mount board. This layer encloses the processor battery. To make battery access easy, this layer is held in place by bent spring clips that are used in several places on the car.","title":"3D Printed Sandwich Mounting"},{"location":"hwdesign/mountingparts.html#mounting-to-the-chassis","text":"There are four mounting points where the car top (which is removed) is attached.The sandwich mounts to these points with the same bent spring clips.","title":"Mounting to the Chassis"},{"location":"hwdesign/mountingparts.html#mounting-the-camera","text":"A useful feature might be to have a pan and tilt camera on the car. The full implementation of this will take place later, but there is sufficient room to mount the Adafruit Pan/Tilt mechanism. The camera mount location is based on this mechanism's requirements. A 3D print of a fixed camera will use these mounting points.","title":"Mounting the Camera"},{"location":"hwdesign/powerdesign.html","text":"Drive Motor Power Changes The NiMh battery was replaced with a 1.8 Ah LiPo battery. This battery was just enough larger that it didn't fit into the battery holder. Also, care needed to be taken to keep it away from one of the drive gears. In addition, a small panel volt meter and power switch was added. By knowing the characteristics of the battery and the current voltage, a sense of the level of discharge can be determined. The battery characteristics are described below. The power switch is placed on the side of the car so that it can be easily accessed. The LiPo battery has a separate balanced charging cable, so it is not necessary to unplug from the motor circuitry for charging. Computer Power Source The power specification to run the Nano at full performance, supply is 4A at 5V. This accounts for a reasonable peripheral load on the processor. The RC LiPo battery world has many batteries capable of supplying the necessary current. We need the largest battery that will comfortably fit on the car. A 3 cell, 3000 mAh battery fits this need. Three cells produce a nominal voltage of 11.1V, so we will need a buck convertor that is capable of producing 5V at 4A. A Drok 180078 adjustable buck convertor can easily handle this. It also has a built-in voltage and current display. Convertor setup and calibration The test circuit to set up and calibrate the convertor is the same as the circuit for running in the car, except that the processor is replaced by a high wattage resistive load (approximately 1.7 ohms). The following image shows this configuration. Refer to the Drok Buck Convertor Manual for how to operate the convertor and details for the calibration process. Calibration process: Apply power to the test circuit. Adjust the 'ADJ-V' and 'ADJ-I' controls so that the output is 5V and the 'Constant Current Indicator' is off. Connect a voltmeter to the input terminals. If the voltage doesn't match the display voltage, follow the 'Voltage Calibration' procedure in the manual. Connact a current meter in series with the load. If the current doesn't match the display, follow the 'Current Calibration' procedure in the manaual. Short the output terminals. Adjust the 'ADJ-I' poteniometer so that the current limits to a current value of well over 3A. Note: this value should be close to 4A, to insure proper operation with the processor. Even though the regulator should output 5A, in practice it may not. If you do not have a current meter, this article on Measuring Low Resistance can help lead to a process to establish the current calibration. Battery Discharge Testing Since the processor on this car doesn't have any devices that draw significant power and Jetson Nano itself is only rated at 10W (2A at 5V), we set a reasonable maximum current draw at 3A for testing the time a battery can power the processor. A resistive load approximately 1.7 ohms will pull 3A at around 5V. For purposes of this test, adjust 'ADJ-V' control so that the output current is at 3A. While the voltage is above 9V (min load voltage) record the time each time the input voltage display drops by 0.1V. The data collected was then used to plot the following graph. At this load, the battery supplies sufficient power for an hour and 45 minutes. Near the battery end-of-charge the input voltage falls off very rapidly.","title":"Power Design"},{"location":"hwdesign/powerdesign.html#drive-motor-power-changes","text":"The NiMh battery was replaced with a 1.8 Ah LiPo battery. This battery was just enough larger that it didn't fit into the battery holder. Also, care needed to be taken to keep it away from one of the drive gears. In addition, a small panel volt meter and power switch was added. By knowing the characteristics of the battery and the current voltage, a sense of the level of discharge can be determined. The battery characteristics are described below. The power switch is placed on the side of the car so that it can be easily accessed. The LiPo battery has a separate balanced charging cable, so it is not necessary to unplug from the motor circuitry for charging.","title":"Drive Motor Power Changes"},{"location":"hwdesign/powerdesign.html#computer-power-source","text":"The power specification to run the Nano at full performance, supply is 4A at 5V. This accounts for a reasonable peripheral load on the processor. The RC LiPo battery world has many batteries capable of supplying the necessary current. We need the largest battery that will comfortably fit on the car. A 3 cell, 3000 mAh battery fits this need. Three cells produce a nominal voltage of 11.1V, so we will need a buck convertor that is capable of producing 5V at 4A. A Drok 180078 adjustable buck convertor can easily handle this. It also has a built-in voltage and current display.","title":"Computer Power Source"},{"location":"hwdesign/powerdesign.html#convertor-setup-and-calibration","text":"The test circuit to set up and calibrate the convertor is the same as the circuit for running in the car, except that the processor is replaced by a high wattage resistive load (approximately 1.7 ohms). The following image shows this configuration. Refer to the Drok Buck Convertor Manual for how to operate the convertor and details for the calibration process. Calibration process: Apply power to the test circuit. Adjust the 'ADJ-V' and 'ADJ-I' controls so that the output is 5V and the 'Constant Current Indicator' is off. Connect a voltmeter to the input terminals. If the voltage doesn't match the display voltage, follow the 'Voltage Calibration' procedure in the manual. Connact a current meter in series with the load. If the current doesn't match the display, follow the 'Current Calibration' procedure in the manaual. Short the output terminals. Adjust the 'ADJ-I' poteniometer so that the current limits to a current value of well over 3A. Note: this value should be close to 4A, to insure proper operation with the processor. Even though the regulator should output 5A, in practice it may not. If you do not have a current meter, this article on Measuring Low Resistance can help lead to a process to establish the current calibration.","title":"Convertor setup and calibration"},{"location":"hwdesign/powerdesign.html#battery-discharge-testing","text":"Since the processor on this car doesn't have any devices that draw significant power and Jetson Nano itself is only rated at 10W (2A at 5V), we set a reasonable maximum current draw at 3A for testing the time a battery can power the processor. A resistive load approximately 1.7 ohms will pull 3A at around 5V. For purposes of this test, adjust 'ADJ-V' control so that the output current is at 3A. While the voltage is above 9V (min load voltage) record the time each time the input voltage display drops by 0.1V. The data collected was then used to plot the following graph. At this load, the battery supplies sufficient power for an hour and 45 minutes. Near the battery end-of-charge the input voltage falls off very rapidly.","title":"Battery Discharge Testing"},{"location":"hwdesign/wiremanagement.html","text":"Issues The batteries are capable of producing high currents and thus have large diameter wires. The space in which to connect and route wires is rather limited. These wires need to be routed through switches and connected to power regulators and voltmeters. These devices don't all handle the large wire sizes very well. In order to make changes or repairs to the car, as much as possible, pluggable connections will be used. To disassemble the car, we'd like to avoid having to get out a soldering iron. Battery Wires and Connectors The LiPo batteries come with XT60 connectors with 12AWG silicon wire. The silicon wire is fortunately very flexable, but still occuppies a fair amount of space. The following table lists the specifications for the batteries used. Battery Capacity (Ah) Discharge Rating (cont-peak C) Cell Count / Voltage Computer 3 20C-30C 3 / 11.1V Drive System 1.8 20-30C 2 / 7.4V The safe discharge current is the product of the discharge rating and the battery capacity. For the cmputer battery that is 3A * 20 or 60A. The peak discharge current is 90A. The battery uses the XT60 connector which is rated at 60A and has a peak current rating of much higher. Similarly the drive system battery is capable of producing a discharge current of 36A. General wire parameters are listed in the following table for various wire sizes. Gauge (AWG) Diameter Resistance (per km) Max Current (In Jacket) 10 2.5883mm 3.28\u03a9 15A 12 2.0523mm 5.21\u03a9 9.3A 14 1.6281mm 8.28\u03a9 5.9A 16 1.2903mm 13.17\u03a9 3.7A 18 1.0236mm 20.94\u03a9 2.3A 20 0.8128mm 33.29\u03a9 1.5A 22 0.6452mm 52.94\u03a9 0.92A 24 0.5105mm 84.20\u03a9 0.577A The maximum current capacity is determined from the maximum allowed temperature increase in the wire (as well as a few other parameters). The silicon coated wire in the battery cable, can withstand a much higher temperature increase than more traditional wire coatings so 12AWG will handle the necessary currents from the battery. Computer Current Draw The external power supply must be able to supply 4A at 5V. This is far lower than the capability of the LiPo battery, so wmaller wire sizes can be employed after the battery cable. Care needs to be taken when buying barrel jacks with pigtails already on them. There are two varieties, both listed for powering devices. One comes with 18AWG wire and the other with 22AWG wire. The 22AWG wire gets hot under a 3A load and drops substantial voltage, not good for input to the processor. Drive System Current Draw The ESC in connected with much smaller wires than the battery. It also uses a min-Tamiya connector as well. The min-Tamiya connector has 10A rating, which is much below the battery output capability. The wire size appears to be around 18AWG as well. The NiMH battery that came with the car is rated at 1100mAh. Using the 2 to 3C discharge rate of 2-3C for NiMH, then we can expect around a 3A max draw from the battery. Power Regulator Connections In early testing, it was difficult to keep the stranded wires tight in the screw terminals on the board. Since there is a very tight space it could be difficult to achieve a reliable connection and it the wire works loose, it given the power in the battery, this could cause serious problems. Using ferrules on the ends of the wires elminates this problem. In doing this, the maximum wire size that will fit in the connector is 18AWG. For the current that will be passing through this device, this is sufficient since the wire lengths are all relatively short. Connecting the Elements Since the maximum commputer and drive system current draws are much less than the battery capability, we can use smaller wire sizes and lower power components fit the space requirements. A convenient and inexpensive rocker power switch with a 20A current rating is more than ample. Where possible, crimp connectors will be used, so that things can just get plugged and unplugged as necessary.","title":"Wire Management"},{"location":"hwdesign/wiremanagement.html#issues","text":"The batteries are capable of producing high currents and thus have large diameter wires. The space in which to connect and route wires is rather limited. These wires need to be routed through switches and connected to power regulators and voltmeters. These devices don't all handle the large wire sizes very well. In order to make changes or repairs to the car, as much as possible, pluggable connections will be used. To disassemble the car, we'd like to avoid having to get out a soldering iron.","title":"Issues"},{"location":"hwdesign/wiremanagement.html#battery-wires-and-connectors","text":"The LiPo batteries come with XT60 connectors with 12AWG silicon wire. The silicon wire is fortunately very flexable, but still occuppies a fair amount of space. The following table lists the specifications for the batteries used. Battery Capacity (Ah) Discharge Rating (cont-peak C) Cell Count / Voltage Computer 3 20C-30C 3 / 11.1V Drive System 1.8 20-30C 2 / 7.4V The safe discharge current is the product of the discharge rating and the battery capacity. For the cmputer battery that is 3A * 20 or 60A. The peak discharge current is 90A. The battery uses the XT60 connector which is rated at 60A and has a peak current rating of much higher. Similarly the drive system battery is capable of producing a discharge current of 36A. General wire parameters are listed in the following table for various wire sizes. Gauge (AWG) Diameter Resistance (per km) Max Current (In Jacket) 10 2.5883mm 3.28\u03a9 15A 12 2.0523mm 5.21\u03a9 9.3A 14 1.6281mm 8.28\u03a9 5.9A 16 1.2903mm 13.17\u03a9 3.7A 18 1.0236mm 20.94\u03a9 2.3A 20 0.8128mm 33.29\u03a9 1.5A 22 0.6452mm 52.94\u03a9 0.92A 24 0.5105mm 84.20\u03a9 0.577A The maximum current capacity is determined from the maximum allowed temperature increase in the wire (as well as a few other parameters). The silicon coated wire in the battery cable, can withstand a much higher temperature increase than more traditional wire coatings so 12AWG will handle the necessary currents from the battery.","title":"Battery Wires and Connectors"},{"location":"hwdesign/wiremanagement.html#computer-current-draw","text":"The external power supply must be able to supply 4A at 5V. This is far lower than the capability of the LiPo battery, so wmaller wire sizes can be employed after the battery cable. Care needs to be taken when buying barrel jacks with pigtails already on them. There are two varieties, both listed for powering devices. One comes with 18AWG wire and the other with 22AWG wire. The 22AWG wire gets hot under a 3A load and drops substantial voltage, not good for input to the processor.","title":"Computer Current Draw"},{"location":"hwdesign/wiremanagement.html#drive-system-current-draw","text":"The ESC in connected with much smaller wires than the battery. It also uses a min-Tamiya connector as well. The min-Tamiya connector has 10A rating, which is much below the battery output capability. The wire size appears to be around 18AWG as well. The NiMH battery that came with the car is rated at 1100mAh. Using the 2 to 3C discharge rate of 2-3C for NiMH, then we can expect around a 3A max draw from the battery.","title":"Drive System Current Draw"},{"location":"hwdesign/wiremanagement.html#power-regulator-connections","text":"In early testing, it was difficult to keep the stranded wires tight in the screw terminals on the board. Since there is a very tight space it could be difficult to achieve a reliable connection and it the wire works loose, it given the power in the battery, this could cause serious problems. Using ferrules on the ends of the wires elminates this problem. In doing this, the maximum wire size that will fit in the connector is 18AWG. For the current that will be passing through this device, this is sufficient since the wire lengths are all relatively short.","title":"Power Regulator Connections"},{"location":"hwdesign/wiremanagement.html#connecting-the-elements","text":"Since the maximum commputer and drive system current draws are much less than the battery capability, we can use smaller wire sizes and lower power components fit the space requirements. A convenient and inexpensive rocker power switch with a 20A current rating is more than ample. Where possible, crimp connectors will be used, so that things can just get plugged and unplugged as necessary.","title":"Connecting the Elements"},{"location":"swdesign/camera.html","text":"Camera, GSTREAMER and the DISPLAY Variable The Pi Camera is connected through the CSI port on the Jetson Nano. This port is operated through the GSTREAMER interface. While this interface provides a lot of useful features, it is very finicky and makes some operations like displaying camera output on a remote host difficult. NVIDIA Jetson Linux Driver Package Software Features and the Accelerated GSTREAMER User Guide describe much about the jetson nano with numerous GSTREAMER examples. One big issue for the linux/X11 environment is the setting of the DISPLAY variable. When a local display is attached, the DISPLAY variable is usually something like: DISPLAY=:0 The DISPLAY variable is also undefined when a simple remote login occurs: ssh donkey@scrambler.local In both these situations, connecting to the camera works fine. If you would like to simply send video to a remote display, or open X Windows on a remote host as in a headless situation, you might login to the Jetson Nano via: ssh -X donkey@scrambler.local In this case, the DISPLAY variable is set to something like: DISPLAY=localhost:10.0 and the camera connection cannot be established. It is just the camera connection that breaks. Other GSTREAMER sources, such as the video test signal generator continue to work just fine, although the sink element in the stream may need to be modified. Video Test Pattern Operation To illustrate this, the following test signal script works on the local and remote display environments. gst-launch-1.0 videotestsrc pattern=smpte ! \\ 'video/x-raw, width=(int)640, height=(int)480, \\ framerate=(fraction)20/1' ! \\ xvimagesink -e It produces the following display: The noise pattern in the lower portion of the screen updates at normal speeds on the local display, but is very slow on the remote display, illustrating bandwidth limitations over WiFi. In fact, a warning is issued about the speed of the computer. Camera Streams Run Local Display Only When replacing the test signal generator with the camera, everything continues to run fine on the local display, but fails on the remote display. gst-launch-1.0 nvarguscamerasrc ! \\ 'video/x-raw(memory:NVMM), width=(int)640, height=(int)480, \\ format=(string)NV12, framerate=(fraction)20/1' ! \\ nvvidconv flip-method=2 ! \\ xvimagesink -e Fix for Remote Display Operation One way to work around this problem is to modify the DISPLAY variable before instantiating the camera through the GSTREAMER. This can easily be done in python using opencv. The following code illustrates this. import os import cv2 # Work around DISPLAY issues disp = os.environ[\"DISPLAY\"] os.environ[\"DISPLAY\"] = ':0' # Set video size information width = 640 height = 480 fps = 10 # Create a VideoCapture object gst_str = ('nvarguscamerasrc ! ' 'video/x-raw(memory:NVMM), ' 'width=(int)1280, height=(int)720, ' 'format=(string)NV12, framerate=(fraction)%d/1 ! ' 'nvvidconv flip-method=2 ! ' 'video/x-raw, ' 'width=(int)%d, height=(int)%d, format=(string)BGRx ! ' 'videoconvert ! ' 'appsink' % (fps, width, height)) cap = cv2.VideoCapture(gst_str, cv2.CAP_GSTREAMER) # Check if camera opened successfully if (cap.isOpened() == False): print(\"Unable to read camera feed\") # Put back the display environment os.environ[\"DISPLAY\"] = disp winName = \"CameraWin\" cv2.namedWindow(winName, cv2.WINDOW_NORMAL) cv2.resizeWindow(winName, width, height) cv2.setWindowTitle(winName, \"Preview\") while(True): ret, frame = cap.read() if ret == True: # Display the resulting frame cv2.imshow(winName, frame) # Press q on keyboard exit key = cv2.waitKey(1) & 0xFF if key == ord('q'): #focus must be in the display window to work break if cv2.getWindowProperty(winName, 0) < 0: #see if user closed the window break # Break the loop else: break # When everything done, release the video capture object cap.release() # Closes all the frames cv2.destroyAllWindows() This now handles remote displays, however, transmitting raw video over WiFi is slow. Compressing video before tranmission, should give the necessary improvements.","title":"Pi Camera Usage"},{"location":"swdesign/camera.html#camera-gstreamer-and-the-display-variable","text":"The Pi Camera is connected through the CSI port on the Jetson Nano. This port is operated through the GSTREAMER interface. While this interface provides a lot of useful features, it is very finicky and makes some operations like displaying camera output on a remote host difficult. NVIDIA Jetson Linux Driver Package Software Features and the Accelerated GSTREAMER User Guide describe much about the jetson nano with numerous GSTREAMER examples. One big issue for the linux/X11 environment is the setting of the DISPLAY variable. When a local display is attached, the DISPLAY variable is usually something like: DISPLAY=:0 The DISPLAY variable is also undefined when a simple remote login occurs: ssh donkey@scrambler.local In both these situations, connecting to the camera works fine. If you would like to simply send video to a remote display, or open X Windows on a remote host as in a headless situation, you might login to the Jetson Nano via: ssh -X donkey@scrambler.local In this case, the DISPLAY variable is set to something like: DISPLAY=localhost:10.0 and the camera connection cannot be established. It is just the camera connection that breaks. Other GSTREAMER sources, such as the video test signal generator continue to work just fine, although the sink element in the stream may need to be modified.","title":"Camera, GSTREAMER and the DISPLAY Variable"},{"location":"swdesign/camera.html#video-test-pattern-operation","text":"To illustrate this, the following test signal script works on the local and remote display environments. gst-launch-1.0 videotestsrc pattern=smpte ! \\ 'video/x-raw, width=(int)640, height=(int)480, \\ framerate=(fraction)20/1' ! \\ xvimagesink -e It produces the following display: The noise pattern in the lower portion of the screen updates at normal speeds on the local display, but is very slow on the remote display, illustrating bandwidth limitations over WiFi. In fact, a warning is issued about the speed of the computer.","title":"Video Test Pattern Operation"},{"location":"swdesign/camera.html#camera-streams-run-local-display-only","text":"When replacing the test signal generator with the camera, everything continues to run fine on the local display, but fails on the remote display. gst-launch-1.0 nvarguscamerasrc ! \\ 'video/x-raw(memory:NVMM), width=(int)640, height=(int)480, \\ format=(string)NV12, framerate=(fraction)20/1' ! \\ nvvidconv flip-method=2 ! \\ xvimagesink -e","title":"Camera Streams Run Local Display Only"},{"location":"swdesign/camera.html#fix-for-remote-display-operation","text":"One way to work around this problem is to modify the DISPLAY variable before instantiating the camera through the GSTREAMER. This can easily be done in python using opencv. The following code illustrates this. import os import cv2 # Work around DISPLAY issues disp = os.environ[\"DISPLAY\"] os.environ[\"DISPLAY\"] = ':0' # Set video size information width = 640 height = 480 fps = 10 # Create a VideoCapture object gst_str = ('nvarguscamerasrc ! ' 'video/x-raw(memory:NVMM), ' 'width=(int)1280, height=(int)720, ' 'format=(string)NV12, framerate=(fraction)%d/1 ! ' 'nvvidconv flip-method=2 ! ' 'video/x-raw, ' 'width=(int)%d, height=(int)%d, format=(string)BGRx ! ' 'videoconvert ! ' 'appsink' % (fps, width, height)) cap = cv2.VideoCapture(gst_str, cv2.CAP_GSTREAMER) # Check if camera opened successfully if (cap.isOpened() == False): print(\"Unable to read camera feed\") # Put back the display environment os.environ[\"DISPLAY\"] = disp winName = \"CameraWin\" cv2.namedWindow(winName, cv2.WINDOW_NORMAL) cv2.resizeWindow(winName, width, height) cv2.setWindowTitle(winName, \"Preview\") while(True): ret, frame = cap.read() if ret == True: # Display the resulting frame cv2.imshow(winName, frame) # Press q on keyboard exit key = cv2.waitKey(1) & 0xFF if key == ord('q'): #focus must be in the display window to work break if cv2.getWindowProperty(winName, 0) < 0: #see if user closed the window break # Break the loop else: break # When everything done, release the video capture object cap.release() # Closes all the frames cv2.destroyAllWindows() This now handles remote displays, however, transmitting raw video over WiFi is slow. Compressing video before tranmission, should give the necessary improvements.","title":"Fix for Remote Display Operation"},{"location":"swdesign/camera_cal.html","text":"Introduction The process of calibrating pinhole cameras has bee around for a long. OpenCV has a set of routines to perform the mathematics for this. There are several tutorial articals and videos on doing this. Two very good articles on this are: OpenCV Tutorials Satya Mallick's Camera Calibration using OpenCV Another Python There are three basic steps to this process: Acquire a set of checkerboard or circle test pattern images from the camera to calibrate. Run the camera calibration program and save coefficients to be used for reconstruction. Develop setup code the properly correct the image. This code will be inserted in the application that is run when the image is to be corrected. Acquiring Calibration Images Print a copy of the checkerboard and/or circles test images. These images are downloadable from Checkerboard and Circles . They are also stored in the development directory as pattern.png and acircles_pattern.png .","title":"Camera Calibration"},{"location":"swdesign/camera_cal.html#introduction","text":"The process of calibrating pinhole cameras has bee around for a long. OpenCV has a set of routines to perform the mathematics for this. There are several tutorial articals and videos on doing this. Two very good articles on this are: OpenCV Tutorials Satya Mallick's Camera Calibration using OpenCV Another Python There are three basic steps to this process: Acquire a set of checkerboard or circle test pattern images from the camera to calibrate. Run the camera calibration program and save coefficients to be used for reconstruction. Develop setup code the properly correct the image. This code will be inserted in the application that is run when the image is to be corrected.","title":"Introduction"},{"location":"swdesign/camera_cal.html#acquiring-calibration-images","text":"Print a copy of the checkerboard and/or circles test images. These images are downloadable from Checkerboard and Circles . They are also stored in the development directory as pattern.png and acircles_pattern.png .","title":"Acquiring Calibration Images"},{"location":"swdesign/gstreamer.html","text":"Introduction The linux image for the jetson nano already comes with the gstreamer installed. There are no python interfaces included with this, except for opencv which has added a camera interface. This if fine if you are only interested in grabbing baseband images to further process. If you would like to take an image and compress it with the gstreamer inside of an application, you are out of luck. The purpose of this exercise is to set up an environment to use the gstreamer inside a python program. Gstreamer Installation To start with a new virtual environment was created: cpvirtualenv car gst Note: if things go awry we can use 'rmvirtualenv' to clean up this mess. Nvidia's Accelerated Gstreamer Guide is followed here to insure the necessary gstreamer environment for the Jetson Nano is installed. Installation follows these steps: sudo add-apt-repository universe sudo add-apt-repository multiverse sudo apt-get update sudo apt-get install gstreamer1.0-tools gstreamer1.0-alsa \\ gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly \\ gstreamer1.0-libav sudo apt-get install libgstreamer1.0-dev \\ libgstreamer-plugins-base1.0-dev \\ libgstreamer-plugins-good1.0-dev \\ libgstreamer-plugins-bad1.0-dev To check the installation of GStreamer issue the following command: gst-inspect-1.0 --version It should cleanly return some version information. In following the \" How to install Gstreamer Python Bindings \" discovered that the API Check produced errors, so we need to build from source. This failed also, as it couldn't resolve PyGObject module. However, the following commands were issued which seem to have installed sufficient tools to run: sudo apt-get install python3-gi python-gst-1.0 sudo apt-get install libgirepository1.0-dev sudo apt-get install libcairo2-dev gir1.2-gstreamer-1.0 pip install --upgrade wheel pip setuptools pip install pycairo pip install PyGObject` Run the following test script to check installation: python -c \"import gi; gi.require_version('Gst', '1.0'); \\ gi.require_version('GstApp', '1.0'); \\ gi.require_version('GstVideo', '1.0'); \\ gi.require_version('GstBase', '1.0')\"","title":"GSTREAMER Python Bindings"},{"location":"swdesign/gstreamer.html#introduction","text":"The linux image for the jetson nano already comes with the gstreamer installed. There are no python interfaces included with this, except for opencv which has added a camera interface. This if fine if you are only interested in grabbing baseband images to further process. If you would like to take an image and compress it with the gstreamer inside of an application, you are out of luck. The purpose of this exercise is to set up an environment to use the gstreamer inside a python program.","title":"Introduction"},{"location":"swdesign/gstreamer.html#gstreamer-installation","text":"To start with a new virtual environment was created: cpvirtualenv car gst Note: if things go awry we can use 'rmvirtualenv' to clean up this mess. Nvidia's Accelerated Gstreamer Guide is followed here to insure the necessary gstreamer environment for the Jetson Nano is installed. Installation follows these steps: sudo add-apt-repository universe sudo add-apt-repository multiverse sudo apt-get update sudo apt-get install gstreamer1.0-tools gstreamer1.0-alsa \\ gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly \\ gstreamer1.0-libav sudo apt-get install libgstreamer1.0-dev \\ libgstreamer-plugins-base1.0-dev \\ libgstreamer-plugins-good1.0-dev \\ libgstreamer-plugins-bad1.0-dev To check the installation of GStreamer issue the following command: gst-inspect-1.0 --version It should cleanly return some version information. In following the \" How to install Gstreamer Python Bindings \" discovered that the API Check produced errors, so we need to build from source. This failed also, as it couldn't resolve PyGObject module. However, the following commands were issued which seem to have installed sufficient tools to run: sudo apt-get install python3-gi python-gst-1.0 sudo apt-get install libgirepository1.0-dev sudo apt-get install libcairo2-dev gir1.2-gstreamer-1.0 pip install --upgrade wheel pip setuptools pip install pycairo pip install PyGObject` Run the following test script to check installation: python -c \"import gi; gi.require_version('Gst', '1.0'); \\ gi.require_version('GstApp', '1.0'); \\ gi.require_version('GstVideo', '1.0'); \\ gi.require_version('GstBase', '1.0')\"","title":"Gstreamer Installation"},{"location":"swdesign/hotspot.html","text":"Hotspot Explored hotspot creation as a means to setup WiFi access to a local host in environments that it is difficult to connect to the local network system. This article discusses setting up a hotspot between the Jetson nano and a linux laptop. Jetson Nano as the Hotspot I ran a little experiment to see how feasable this is. Plugged a spare Edimax WiFi module into the host. Issued the command to see if it is discovered: nmcli d # output shows the device is disconnected Connect USB cable between host and nano. Login to the nano from the host on this port. screen /dev/ttyACM0 115200 # Login to nano Issue the following commands to setup the hotspot # Shutdown current network connection sudo nmcli c down <current-connected-SSID> # Create a hotspot named 'scrambler' sudo nmcli -a dev wifi hotspot ifname wlan0 ssid scrambler # see if the device is connected as a hotspot nmcli c # Setup priority for auto-connect # (needs priorities set for other networks as well) # Did not actually test this out sudo nmcli c midufy scrambler connection.autoconnect-priority <int> From the host, connect to the hotspot # find the SSID nmcli d wifi list # connect to the network sudo nmcli -a d wifi connect scrambler # See which IP addresses it gave us route -n # remote login to the nano ssh donkey@10.42.0.1 It seems like there are a few other parameters that should be set up, but it does work. Local Host as the Hotspot If the local host is equiped with the extra WiFi adapter and it is the hotspot, then we can use it to manage the traffic and perhaps set up the passthrough to the web, all without burdoning the Jetson Nano which is really intended for other tasks. Using the grahical interface on the host is the easiest way to setup the interface. This site describes the process for doing this on Ubuntu 18.04. settings->wifi select the network device (may have to connect to a network first) menu bar->Turn On Wi-Fi Hotspot... remember password When this is up and running you can just connect to it from the nano as before. This also routes the nano out to the web as necessary.","title":"Hotspot Setup"},{"location":"swdesign/hotspot.html#hotspot","text":"Explored hotspot creation as a means to setup WiFi access to a local host in environments that it is difficult to connect to the local network system. This article discusses setting up a hotspot between the Jetson nano and a linux laptop.","title":"Hotspot"},{"location":"swdesign/hotspot.html#jetson-nano-as-the-hotspot","text":"I ran a little experiment to see how feasable this is. Plugged a spare Edimax WiFi module into the host. Issued the command to see if it is discovered: nmcli d # output shows the device is disconnected Connect USB cable between host and nano. Login to the nano from the host on this port. screen /dev/ttyACM0 115200 # Login to nano Issue the following commands to setup the hotspot # Shutdown current network connection sudo nmcli c down <current-connected-SSID> # Create a hotspot named 'scrambler' sudo nmcli -a dev wifi hotspot ifname wlan0 ssid scrambler # see if the device is connected as a hotspot nmcli c # Setup priority for auto-connect # (needs priorities set for other networks as well) # Did not actually test this out sudo nmcli c midufy scrambler connection.autoconnect-priority <int> From the host, connect to the hotspot # find the SSID nmcli d wifi list # connect to the network sudo nmcli -a d wifi connect scrambler # See which IP addresses it gave us route -n # remote login to the nano ssh donkey@10.42.0.1 It seems like there are a few other parameters that should be set up, but it does work.","title":"Jetson Nano as the Hotspot"},{"location":"swdesign/hotspot.html#local-host-as-the-hotspot","text":"If the local host is equiped with the extra WiFi adapter and it is the hotspot, then we can use it to manage the traffic and perhaps set up the passthrough to the web, all without burdoning the Jetson Nano which is really intended for other tasks. Using the grahical interface on the host is the easiest way to setup the interface. This site describes the process for doing this on Ubuntu 18.04. settings->wifi select the network device (may have to connect to a network first) menu bar->Turn On Wi-Fi Hotspot... remember password When this is up and running you can just connect to it from the nano as before. This also routes the nano out to the web as necessary.","title":"Local Host as the Hotspot"},{"location":"swdesign/joystick.html","text":"Introduction Explore the basic connections to interfacing with the joystick. Looking for simple interface so that it can be used for other test programs. In looking at the donkey car interface, they build a driver through ioictl calls to the joystick port in linux ( /dev/input/js0 ). Since we are only using the Logitech F710, we won't worry about the plethora of other types to interface to. It would probably suffice to lift the necessary parts from the controller.py file in the donkey car, but we'll start with a standard linux test program. When looking into the joystick interface there are many terms and definitions that come up. The Linux Kernel Documentation provides a great amount of detail on this information. jstest-gtk This is a simple joystick tester written in c++ and can be found at the jstest-gtk . It has been downloaded into the ~/project/jstest directory. The README.md gives the necessary instructions to compile and run it. Before running this, you will want to remotely log in via: ssh -X donkey@scrambler.local since it brings up a window displaying the joystick controls. Before compiling, you will also have to do the following to get thenecessary libraies: sudo apt-get install sigc++ sudo apt-get install libgtkmm-3.0-dev Once compiled it can be executed from the build directory via: ./jstest-gtk /dev/input/js0 js_linux.py program This js_linux.py was grabbed from the internet. It is rather simple and runs straight away, so it should serve as a vehicle to quickly generate drivers that we are interested in. It also appears that this was the driver that the Donkeycar used to develop their joystick (controller.py) from. Joystick Driver Converted js_linux.py to class Joystick and added a subclass of F710Joystick. In addition, reading of the joystick values was converted to nonblocking I/O. This seems to make sense for more general usage. A timeout on the read time could also have been used, or even more generically, put a polling loop as a separate thread. For now, it is left as a simple driver that must be polled regularly to keep the event queue on the joystick from filling up. It keeps a current state of the joysticks and buttons. It also can just return events as they come in. Final tweaks can wait until we put it in an application and see what is really needed.","title":"Joystick Testing"},{"location":"swdesign/joystick.html#introduction","text":"Explore the basic connections to interfacing with the joystick. Looking for simple interface so that it can be used for other test programs. In looking at the donkey car interface, they build a driver through ioictl calls to the joystick port in linux ( /dev/input/js0 ). Since we are only using the Logitech F710, we won't worry about the plethora of other types to interface to. It would probably suffice to lift the necessary parts from the controller.py file in the donkey car, but we'll start with a standard linux test program. When looking into the joystick interface there are many terms and definitions that come up. The Linux Kernel Documentation provides a great amount of detail on this information.","title":"Introduction"},{"location":"swdesign/joystick.html#jstest-gtk","text":"This is a simple joystick tester written in c++ and can be found at the jstest-gtk . It has been downloaded into the ~/project/jstest directory. The README.md gives the necessary instructions to compile and run it. Before running this, you will want to remotely log in via: ssh -X donkey@scrambler.local since it brings up a window displaying the joystick controls. Before compiling, you will also have to do the following to get thenecessary libraies: sudo apt-get install sigc++ sudo apt-get install libgtkmm-3.0-dev Once compiled it can be executed from the build directory via: ./jstest-gtk /dev/input/js0","title":"jstest-gtk"},{"location":"swdesign/joystick.html#js_linuxpy-program","text":"This js_linux.py was grabbed from the internet. It is rather simple and runs straight away, so it should serve as a vehicle to quickly generate drivers that we are interested in. It also appears that this was the driver that the Donkeycar used to develop their joystick (controller.py) from.","title":"js_linux.py program"},{"location":"swdesign/joystick.html#joystick-driver","text":"Converted js_linux.py to class Joystick and added a subclass of F710Joystick. In addition, reading of the joystick values was converted to nonblocking I/O. This seems to make sense for more general usage. A timeout on the read time could also have been used, or even more generically, put a polling loop as a separate thread. For now, it is left as a simple driver that must be polled regularly to keep the event queue on the joystick from filling up. It keeps a current state of the joysticks and buttons. It also can just return events as they come in. Final tweaks can wait until we put it in an application and see what is really needed.","title":"Joystick Driver"},{"location":"swdesign/sysmon.html","text":"Monitoring the Jetson Nano Remotely One of the concerns in running headless, is knowing the status of the processor and network activity. After looking around on the web for sources, many were found. However, they don't necessarily monitor the things we are interested in or in the case of graphical displays, take a lot of network resources. Many of these are written in python and provide examples on how to easily obtain the information desired. Example Monitoring Programs Graphical based: # From host ssh -X donkey@scrambleer.local # From terminal created on nano gnome-system-monitor& This brings up the standard monitor on the remote display. It displays graphically each cpu's usage, memory and the network traffic. Unfortunately, it adds a fair amount the network traffic, so before measuring other traffic levels, you need to get a baseline traffic level from this. In slower environments it may require enough bandwidth, that it falls behind. A simple cpu and gpu monitor was found at this site . It runs under ncurses, so is easier to call remotely. This monitor is located in ~/projects/stat_mon/references. cd ~/project/stat_mon/references python jetson_stats.py This program does not monitor the network activity. To do that, we can use ifstat. It can easily be installed via: sudo apt-get install ifstat The source code is also available and is storedin ~/projects/stats_mon/references. By default it adds a new line to the output every second. This program displays activity for all the I/O ports. To display the WiFi trafiic only: ifstat -i wlan0 Home Grown stat_mon.py The easiest way to get a simple stats monitor was to write a python script. The example programs provide good reference material and were used to guide the developoment. Most of the stats information is readily available by reading pseudo files on the processor. Information about the contents of these files can be found in the web. Two programs were written: stat_mon.py and stat_mon_curses.py . They are essentially the same program, but the curses version adds a few bells to flag high usage items. To run a program: # From host ssh donkey@scrambleer.local # From terminal created on nano cd ~/project/stat_mon python stat_mon.py","title":"System Monitor"},{"location":"swdesign/sysmon.html#monitoring-the-jetson-nano-remotely","text":"One of the concerns in running headless, is knowing the status of the processor and network activity. After looking around on the web for sources, many were found. However, they don't necessarily monitor the things we are interested in or in the case of graphical displays, take a lot of network resources. Many of these are written in python and provide examples on how to easily obtain the information desired.","title":"Monitoring the Jetson Nano Remotely"},{"location":"swdesign/sysmon.html#example-monitoring-programs","text":"Graphical based: # From host ssh -X donkey@scrambleer.local # From terminal created on nano gnome-system-monitor& This brings up the standard monitor on the remote display. It displays graphically each cpu's usage, memory and the network traffic. Unfortunately, it adds a fair amount the network traffic, so before measuring other traffic levels, you need to get a baseline traffic level from this. In slower environments it may require enough bandwidth, that it falls behind. A simple cpu and gpu monitor was found at this site . It runs under ncurses, so is easier to call remotely. This monitor is located in ~/projects/stat_mon/references. cd ~/project/stat_mon/references python jetson_stats.py This program does not monitor the network activity. To do that, we can use ifstat. It can easily be installed via: sudo apt-get install ifstat The source code is also available and is storedin ~/projects/stats_mon/references. By default it adds a new line to the output every second. This program displays activity for all the I/O ports. To display the WiFi trafiic only: ifstat -i wlan0","title":"Example Monitoring Programs"},{"location":"swdesign/sysmon.html#home-grown-stat_monpy","text":"The easiest way to get a simple stats monitor was to write a python script. The example programs provide good reference material and were used to guide the developoment. Most of the stats information is readily available by reading pseudo files on the processor. Information about the contents of these files can be found in the web. Two programs were written: stat_mon.py and stat_mon_curses.py . They are essentially the same program, but the curses version adds a few bells to flag high usage items. To run a program: # From host ssh donkey@scrambleer.local # From terminal created on nano cd ~/project/stat_mon python stat_mon.py","title":"Home Grown stat_mon.py"},{"location":"swdesign/webstream.html","text":"Introduction In order to get resonable video over the to the remote host display, the video stream needs to be compressed then transmitted. The host needs to have something running to receive and display this. A common approach to this is to use the web browser. Jupyter notebooks does this as well as the donkeycar software. To start with, I went looking for a simple app to test this out and see what limitations there are. Using Jetson for Video Streaming discusses video streaming for the Jetson Nano. This program runs, but does not stream uniformly as the video is not sent out smoothly. Video Streaming with Flask gives a more general discussion of the video streaming process. It was not set up for the nano and suffers many of the same problems. Flask Video Streaming Revisited is upgraded from the previous article and addresses more improvements and robustness issues. This program has been modified to run on the nano and the details are discussed below. Naturally, not being an expert on any of these tools, a little study was needed to sort this code out. Flask is the framework used to accomplish this. There is a good tutorial on the from freecodecamp . In viewing this tutorial, one of the first things discovered is that they use python decorators. The Decorators in Python web page covers this in detail. Threading is central to running this web app, a tutorial on threading was consulted. After all is said and done, these example apps did not handle shutting down the Jetson CSI Camera very well. If this is not cleanly done, you are forced to do a reboot to fix the problem. In addition, what appeared to be the best written program, turned out to be very difficult to follow and I couldn't figure out where to insert the necessary code to insure the camera would shutdown correctly. After about so much time, it was time to consider writing the necessary code from scratch. Video Streaming App To run the app, from the host: ssh donkey@scrambler.local # After logging in... pip install flask # if not already installed cd ~/projects/camera/WebStream python web_stream.py One the host, open a blank web page in your chrome browser and enter: scrambler.local:8000 or if the car is connected to a display you can issue the browser command: localhost:8000 Note: you may have to substute the IP address for scrambler.local. You should see the camera output on the display. This program also supports streaming to multiple devices, but performance may get sluggish rather quickly.","title":"Simple Web Streamer"},{"location":"swdesign/webstream.html#introduction","text":"In order to get resonable video over the to the remote host display, the video stream needs to be compressed then transmitted. The host needs to have something running to receive and display this. A common approach to this is to use the web browser. Jupyter notebooks does this as well as the donkeycar software. To start with, I went looking for a simple app to test this out and see what limitations there are. Using Jetson for Video Streaming discusses video streaming for the Jetson Nano. This program runs, but does not stream uniformly as the video is not sent out smoothly. Video Streaming with Flask gives a more general discussion of the video streaming process. It was not set up for the nano and suffers many of the same problems. Flask Video Streaming Revisited is upgraded from the previous article and addresses more improvements and robustness issues. This program has been modified to run on the nano and the details are discussed below. Naturally, not being an expert on any of these tools, a little study was needed to sort this code out. Flask is the framework used to accomplish this. There is a good tutorial on the from freecodecamp . In viewing this tutorial, one of the first things discovered is that they use python decorators. The Decorators in Python web page covers this in detail. Threading is central to running this web app, a tutorial on threading was consulted. After all is said and done, these example apps did not handle shutting down the Jetson CSI Camera very well. If this is not cleanly done, you are forced to do a reboot to fix the problem. In addition, what appeared to be the best written program, turned out to be very difficult to follow and I couldn't figure out where to insert the necessary code to insure the camera would shutdown correctly. After about so much time, it was time to consider writing the necessary code from scratch.","title":"Introduction"},{"location":"swdesign/webstream.html#video-streaming-app","text":"To run the app, from the host: ssh donkey@scrambler.local # After logging in... pip install flask # if not already installed cd ~/projects/camera/WebStream python web_stream.py One the host, open a blank web page in your chrome browser and enter: scrambler.local:8000 or if the car is connected to a display you can issue the browser command: localhost:8000 Note: you may have to substute the IP address for scrambler.local. You should see the camera output on the display. This program also supports streaming to multiple devices, but performance may get sluggish rather quickly.","title":"Video Streaming App"},{"location":"swdesign/workenv.html","text":"Introduction Many times the command line statements to perform certain operations are forgotten and have to be looked up. This section is a collection of the ones that I have had to look up that I expect to use from time to time. Work Environment Adjustments for Development I use 'vi' as the text editor of choice. It defaults to using tabs with 8 spaces. A '.exrc' file is created in the home directory with the following added: :se ts=4 :se expandtab Python Debugging Without the Use of Graphical Tools The documentation descirbes the details of the available operaions. To get started, simply enter the following command. python -m pdb *script.py* Using Pip to Upgrade Modules When upgrading, pip requires a list of modules (there is no all). This script is one way to accomplish this: pip install -U `pip list --outdated | awk 'NR>2 {print $1}'`","title":"Work Environment"},{"location":"swdesign/workenv.html#introduction","text":"Many times the command line statements to perform certain operations are forgotten and have to be looked up. This section is a collection of the ones that I have had to look up that I expect to use from time to time.","title":"Introduction"},{"location":"swdesign/workenv.html#work-environment-adjustments-for-development","text":"I use 'vi' as the text editor of choice. It defaults to using tabs with 8 spaces. A '.exrc' file is created in the home directory with the following added: :se ts=4 :se expandtab","title":"Work Environment Adjustments for Development"},{"location":"swdesign/workenv.html#python-debugging-without-the-use-of-graphical-tools","text":"The documentation descirbes the details of the available operaions. To get started, simply enter the following command. python -m pdb *script.py*","title":"Python Debugging Without the Use of Graphical Tools"},{"location":"swdesign/workenv.html#using-pip-to-upgrade-modules","text":"When upgrading, pip requires a list of modules (there is no all). This script is one way to accomplish this: pip install -U `pip list --outdated | awk 'NR>2 {print $1}'`","title":"Using Pip to Upgrade Modules"}]}